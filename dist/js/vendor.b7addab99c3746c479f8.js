(window.webpackJsonp=window.webpackJsonp||[]).push([[0],[,,function(module,exports,__webpack_require__){"use strict";eval("\n\n__webpack_require__(3)(__webpack_require__(4));\n\n/*** EXPORTS FROM exports-loader ***/\nmodule.exports = window.Zepto;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMi5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9ub2RlX21vZHVsZXMvemVwdG8vZGlzdC96ZXB0by5qcz84YTU4Il0sInNvdXJjZXNDb250ZW50IjpbInJlcXVpcmUoXCIhIUQ6XFxcXHN0dWR5XFxcXHdlYnBhY2s0X21wYV9kZW1vXFxcXG5vZGVfbW9kdWxlc1xcXFxzY3JpcHQtbG9hZGVyXFxcXGFkZFNjcmlwdC5qc1wiKShyZXF1aXJlKFwiISFEOlxcXFxzdHVkeVxcXFx3ZWJwYWNrNF9tcGFfZGVtb1xcXFxub2RlX21vZHVsZXNcXFxccmF3LWxvYWRlclxcXFxpbmRleC5qcyFEOlxcXFxzdHVkeVxcXFx3ZWJwYWNrNF9tcGFfZGVtb1xcXFxub2RlX21vZHVsZXNcXFxcemVwdG9cXFxcZGlzdFxcXFx6ZXB0by5qc1wiKSlcblxuLyoqKiBFWFBPUlRTIEZST00gZXhwb3J0cy1sb2FkZXIgKioqL1xubW9kdWxlLmV4cG9ydHMgPSB3aW5kb3cuWmVwdG87Il0sIm1hcHBpbmdzIjoiOztBQUFBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///2\n")},function(module,exports){eval('/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\nmodule.exports = function(src) {\n\tfunction log(error) {\n\t\t(typeof console !== "undefined")\n\t\t&& (console.error || console.log)("[Script Loader]", error);\n\t}\n\n\t// Check for IE =< 8\n\tfunction isIE() {\n\t\treturn typeof attachEvent !== "undefined" && typeof addEventListener === "undefined";\n\t}\n\n\ttry {\n\t\tif (typeof execScript !== "undefined" && isIE()) {\n\t\t\texecScript(src);\n\t\t} else if (typeof eval !== "undefined") {\n\t\t\teval.call(null, src);\n\t\t} else {\n\t\t\tlog("EvalError: No eval function available");\n\t\t}\n\t} catch (error) {\n\t\tlog(error);\n\t}\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zY3JpcHQtbG9hZGVyL2FkZFNjcmlwdC5qcz9mMmI1Il0sInNvdXJjZXNDb250ZW50IjpbIi8qXG5cdE1JVCBMaWNlbnNlIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwXG5cdEF1dGhvciBUb2JpYXMgS29wcGVycyBAc29rcmFcbiovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHNyYykge1xuXHRmdW5jdGlvbiBsb2coZXJyb3IpIHtcblx0XHQodHlwZW9mIGNvbnNvbGUgIT09IFwidW5kZWZpbmVkXCIpXG5cdFx0JiYgKGNvbnNvbGUuZXJyb3IgfHwgY29uc29sZS5sb2cpKFwiW1NjcmlwdCBMb2FkZXJdXCIsIGVycm9yKTtcblx0fVxuXG5cdC8vIENoZWNrIGZvciBJRSA9PCA4XG5cdGZ1bmN0aW9uIGlzSUUoKSB7XG5cdFx0cmV0dXJuIHR5cGVvZiBhdHRhY2hFdmVudCAhPT0gXCJ1bmRlZmluZWRcIiAmJiB0eXBlb2YgYWRkRXZlbnRMaXN0ZW5lciA9PT0gXCJ1bmRlZmluZWRcIjtcblx0fVxuXG5cdHRyeSB7XG5cdFx0aWYgKHR5cGVvZiBleGVjU2NyaXB0ICE9PSBcInVuZGVmaW5lZFwiICYmIGlzSUUoKSkge1xuXHRcdFx0ZXhlY1NjcmlwdChzcmMpO1xuXHRcdH0gZWxzZSBpZiAodHlwZW9mIGV2YWwgIT09IFwidW5kZWZpbmVkXCIpIHtcblx0XHRcdGV2YWwuY2FsbChudWxsLCBzcmMpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRsb2coXCJFdmFsRXJyb3I6IE5vIGV2YWwgZnVuY3Rpb24gYXZhaWxhYmxlXCIpO1xuXHRcdH1cblx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHRsb2coZXJyb3IpO1xuXHR9XG59XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///3\n')},function(module,exports){eval("module.exports = \"/* Zepto v1.2.0 - zepto event ajax form ie - zeptojs.com/license */\\n(function(global, factory) {\\n  if (typeof define === 'function' && define.amd)\\n    define(function() { return factory(global) })\\n  else\\n    factory(global)\\n}(this, function(window) {\\n  var Zepto = (function() {\\n  var undefined, key, $, classList, emptyArray = [], concat = emptyArray.concat, filter = emptyArray.filter, slice = emptyArray.slice,\\n    document = window.document,\\n    elementDisplay = {}, classCache = {},\\n    cssNumber = { 'column-count': 1, 'columns': 1, 'font-weight': 1, 'line-height': 1,'opacity': 1, 'z-index': 1, 'zoom': 1 },\\n    fragmentRE = /^\\\\s*<(\\\\w+|!)[^>]*>/,\\n    singleTagRE = /^<(\\\\w+)\\\\s*\\\\/?>(?:<\\\\/\\\\1>|)$/,\\n    tagExpanderRE = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\\\\w:]+)[^>]*)\\\\/>/ig,\\n    rootNodeRE = /^(?:body|html)$/i,\\n    capitalRE = /([A-Z])/g,\\n\\n    // special attributes that should be get/set via method calls\\n    methodAttributes = ['val', 'css', 'html', 'text', 'data', 'width', 'height', 'offset'],\\n\\n    adjacencyOperators = [ 'after', 'prepend', 'before', 'append' ],\\n    table = document.createElement('table'),\\n    tableRow = document.createElement('tr'),\\n    containers = {\\n      'tr': document.createElement('tbody'),\\n      'tbody': table, 'thead': table, 'tfoot': table,\\n      'td': tableRow, 'th': tableRow,\\n      '*': document.createElement('div')\\n    },\\n    readyRE = /complete|loaded|interactive/,\\n    simpleSelectorRE = /^[\\\\w-]*$/,\\n    class2type = {},\\n    toString = class2type.toString,\\n    zepto = {},\\n    camelize, uniq,\\n    tempParent = document.createElement('div'),\\n    propMap = {\\n      'tabindex': 'tabIndex',\\n      'readonly': 'readOnly',\\n      'for': 'htmlFor',\\n      'class': 'className',\\n      'maxlength': 'maxLength',\\n      'cellspacing': 'cellSpacing',\\n      'cellpadding': 'cellPadding',\\n      'rowspan': 'rowSpan',\\n      'colspan': 'colSpan',\\n      'usemap': 'useMap',\\n      'frameborder': 'frameBorder',\\n      'contenteditable': 'contentEditable'\\n    },\\n    isArray = Array.isArray ||\\n      function(object){ return object instanceof Array }\\n\\n  zepto.matches = function(element, selector) {\\n    if (!selector || !element || element.nodeType !== 1) return false\\n    var matchesSelector = element.matches || element.webkitMatchesSelector ||\\n                          element.mozMatchesSelector || element.oMatchesSelector ||\\n                          element.matchesSelector\\n    if (matchesSelector) return matchesSelector.call(element, selector)\\n    // fall back to performing a selector:\\n    var match, parent = element.parentNode, temp = !parent\\n    if (temp) (parent = tempParent).appendChild(element)\\n    match = ~zepto.qsa(parent, selector).indexOf(element)\\n    temp && tempParent.removeChild(element)\\n    return match\\n  }\\n\\n  function type(obj) {\\n    return obj == null ? String(obj) :\\n      class2type[toString.call(obj)] || \\\"object\\\"\\n  }\\n\\n  function isFunction(value) { return type(value) == \\\"function\\\" }\\n  function isWindow(obj)     { return obj != null && obj == obj.window }\\n  function isDocument(obj)   { return obj != null && obj.nodeType == obj.DOCUMENT_NODE }\\n  function isObject(obj)     { return type(obj) == \\\"object\\\" }\\n  function isPlainObject(obj) {\\n    return isObject(obj) && !isWindow(obj) && Object.getPrototypeOf(obj) == Object.prototype\\n  }\\n\\n  function likeArray(obj) {\\n    var length = !!obj && 'length' in obj && obj.length,\\n      type = $.type(obj)\\n\\n    return 'function' != type && !isWindow(obj) && (\\n      'array' == type || length === 0 ||\\n        (typeof length == 'number' && length > 0 && (length - 1) in obj)\\n    )\\n  }\\n\\n  function compact(array) { return filter.call(array, function(item){ return item != null }) }\\n  function flatten(array) { return array.length > 0 ? $.fn.concat.apply([], array) : array }\\n  camelize = function(str){ return str.replace(/-+(.)?/g, function(match, chr){ return chr ? chr.toUpperCase() : '' }) }\\n  function dasherize(str) {\\n    return str.replace(/::/g, '/')\\n           .replace(/([A-Z]+)([A-Z][a-z])/g, '$1_$2')\\n           .replace(/([a-z\\\\d])([A-Z])/g, '$1_$2')\\n           .replace(/_/g, '-')\\n           .toLowerCase()\\n  }\\n  uniq = function(array){ return filter.call(array, function(item, idx){ return array.indexOf(item) == idx }) }\\n\\n  function classRE(name) {\\n    return name in classCache ?\\n      classCache[name] : (classCache[name] = new RegExp('(^|\\\\\\\\s)' + name + '(\\\\\\\\s|$)'))\\n  }\\n\\n  function maybeAddPx(name, value) {\\n    return (typeof value == \\\"number\\\" && !cssNumber[dasherize(name)]) ? value + \\\"px\\\" : value\\n  }\\n\\n  function defaultDisplay(nodeName) {\\n    var element, display\\n    if (!elementDisplay[nodeName]) {\\n      element = document.createElement(nodeName)\\n      document.body.appendChild(element)\\n      display = getComputedStyle(element, '').getPropertyValue(\\\"display\\\")\\n      element.parentNode.removeChild(element)\\n      display == \\\"none\\\" && (display = \\\"block\\\")\\n      elementDisplay[nodeName] = display\\n    }\\n    return elementDisplay[nodeName]\\n  }\\n\\n  function children(element) {\\n    return 'children' in element ?\\n      slice.call(element.children) :\\n      $.map(element.childNodes, function(node){ if (node.nodeType == 1) return node })\\n  }\\n\\n  function Z(dom, selector) {\\n    var i, len = dom ? dom.length : 0\\n    for (i = 0; i < len; i++) this[i] = dom[i]\\n    this.length = len\\n    this.selector = selector || ''\\n  }\\n\\n  // `$.zepto.fragment` takes a html string and an optional tag name\\n  // to generate DOM nodes from the given html string.\\n  // The generated DOM nodes are returned as an array.\\n  // This function can be overridden in plugins for example to make\\n  // it compatible with browsers that don't support the DOM fully.\\n  zepto.fragment = function(html, name, properties) {\\n    var dom, nodes, container\\n\\n    // A special case optimization for a single tag\\n    if (singleTagRE.test(html)) dom = $(document.createElement(RegExp.$1))\\n\\n    if (!dom) {\\n      if (html.replace) html = html.replace(tagExpanderRE, \\\"<$1></$2>\\\")\\n      if (name === undefined) name = fragmentRE.test(html) && RegExp.$1\\n      if (!(name in containers)) name = '*'\\n\\n      container = containers[name]\\n      container.innerHTML = '' + html\\n      dom = $.each(slice.call(container.childNodes), function(){\\n        container.removeChild(this)\\n      })\\n    }\\n\\n    if (isPlainObject(properties)) {\\n      nodes = $(dom)\\n      $.each(properties, function(key, value) {\\n        if (methodAttributes.indexOf(key) > -1) nodes[key](value)\\n        else nodes.attr(key, value)\\n      })\\n    }\\n\\n    return dom\\n  }\\n\\n  // `$.zepto.Z` swaps out the prototype of the given `dom` array\\n  // of nodes with `$.fn` and thus supplying all the Zepto functions\\n  // to the array. This method can be overridden in plugins.\\n  zepto.Z = function(dom, selector) {\\n    return new Z(dom, selector)\\n  }\\n\\n  // `$.zepto.isZ` should return `true` if the given object is a Zepto\\n  // collection. This method can be overridden in plugins.\\n  zepto.isZ = function(object) {\\n    return object instanceof zepto.Z\\n  }\\n\\n  // `$.zepto.init` is Zepto's counterpart to jQuery's `$.fn.init` and\\n  // takes a CSS selector and an optional context (and handles various\\n  // special cases).\\n  // This method can be overridden in plugins.\\n  zepto.init = function(selector, context) {\\n    var dom\\n    // If nothing given, return an empty Zepto collection\\n    if (!selector) return zepto.Z()\\n    // Optimize for string selectors\\n    else if (typeof selector == 'string') {\\n      selector = selector.trim()\\n      // If it's a html fragment, create nodes from it\\n      // Note: In both Chrome 21 and Firefox 15, DOM error 12\\n      // is thrown if the fragment doesn't begin with <\\n      if (selector[0] == '<' && fragmentRE.test(selector))\\n        dom = zepto.fragment(selector, RegExp.$1, context), selector = null\\n      // If there's a context, create a collection on that context first, and select\\n      // nodes from there\\n      else if (context !== undefined) return $(context).find(selector)\\n      // If it's a CSS selector, use it to select nodes.\\n      else dom = zepto.qsa(document, selector)\\n    }\\n    // If a function is given, call it when the DOM is ready\\n    else if (isFunction(selector)) return $(document).ready(selector)\\n    // If a Zepto collection is given, just return it\\n    else if (zepto.isZ(selector)) return selector\\n    else {\\n      // normalize array if an array of nodes is given\\n      if (isArray(selector)) dom = compact(selector)\\n      // Wrap DOM nodes.\\n      else if (isObject(selector))\\n        dom = [selector], selector = null\\n      // If it's a html fragment, create nodes from it\\n      else if (fragmentRE.test(selector))\\n        dom = zepto.fragment(selector.trim(), RegExp.$1, context), selector = null\\n      // If there's a context, create a collection on that context first, and select\\n      // nodes from there\\n      else if (context !== undefined) return $(context).find(selector)\\n      // And last but no least, if it's a CSS selector, use it to select nodes.\\n      else dom = zepto.qsa(document, selector)\\n    }\\n    // create a new Zepto collection from the nodes found\\n    return zepto.Z(dom, selector)\\n  }\\n\\n  // `$` will be the base `Zepto` object. When calling this\\n  // function just call `$.zepto.init, which makes the implementation\\n  // details of selecting nodes and creating Zepto collections\\n  // patchable in plugins.\\n  $ = function(selector, context){\\n    return zepto.init(selector, context)\\n  }\\n\\n  function extend(target, source, deep) {\\n    for (key in source)\\n      if (deep && (isPlainObject(source[key]) || isArray(source[key]))) {\\n        if (isPlainObject(source[key]) && !isPlainObject(target[key]))\\n          target[key] = {}\\n        if (isArray(source[key]) && !isArray(target[key]))\\n          target[key] = []\\n        extend(target[key], source[key], deep)\\n      }\\n      else if (source[key] !== undefined) target[key] = source[key]\\n  }\\n\\n  // Copy all but undefined properties from one or more\\n  // objects to the `target` object.\\n  $.extend = function(target){\\n    var deep, args = slice.call(arguments, 1)\\n    if (typeof target == 'boolean') {\\n      deep = target\\n      target = args.shift()\\n    }\\n    args.forEach(function(arg){ extend(target, arg, deep) })\\n    return target\\n  }\\n\\n  // `$.zepto.qsa` is Zepto's CSS selector implementation which\\n  // uses `document.querySelectorAll` and optimizes for some special cases, like `#id`.\\n  // This method can be overridden in plugins.\\n  zepto.qsa = function(element, selector){\\n    var found,\\n        maybeID = selector[0] == '#',\\n        maybeClass = !maybeID && selector[0] == '.',\\n        nameOnly = maybeID || maybeClass ? selector.slice(1) : selector, // Ensure that a 1 char tag name still gets checked\\n        isSimple = simpleSelectorRE.test(nameOnly)\\n    return (element.getElementById && isSimple && maybeID) ? // Safari DocumentFragment doesn't have getElementById\\n      ( (found = element.getElementById(nameOnly)) ? [found] : [] ) :\\n      (element.nodeType !== 1 && element.nodeType !== 9 && element.nodeType !== 11) ? [] :\\n      slice.call(\\n        isSimple && !maybeID && element.getElementsByClassName ? // DocumentFragment doesn't have getElementsByClassName/TagName\\n          maybeClass ? element.getElementsByClassName(nameOnly) : // If it's simple, it could be a class\\n          element.getElementsByTagName(selector) : // Or a tag\\n          element.querySelectorAll(selector) // Or it's not simple, and we need to query all\\n      )\\n  }\\n\\n  function filtered(nodes, selector) {\\n    return selector == null ? $(nodes) : $(nodes).filter(selector)\\n  }\\n\\n  $.contains = document.documentElement.contains ?\\n    function(parent, node) {\\n      return parent !== node && parent.contains(node)\\n    } :\\n    function(parent, node) {\\n      while (node && (node = node.parentNode))\\n        if (node === parent) return true\\n      return false\\n    }\\n\\n  function funcArg(context, arg, idx, payload) {\\n    return isFunction(arg) ? arg.call(context, idx, payload) : arg\\n  }\\n\\n  function setAttribute(node, name, value) {\\n    value == null ? node.removeAttribute(name) : node.setAttribute(name, value)\\n  }\\n\\n  // access className property while respecting SVGAnimatedString\\n  function className(node, value){\\n    var klass = node.className || '',\\n        svg   = klass && klass.baseVal !== undefined\\n\\n    if (value === undefined) return svg ? klass.baseVal : klass\\n    svg ? (klass.baseVal = value) : (node.className = value)\\n  }\\n\\n  // \\\"true\\\"  => true\\n  // \\\"false\\\" => false\\n  // \\\"null\\\"  => null\\n  // \\\"42\\\"    => 42\\n  // \\\"42.5\\\"  => 42.5\\n  // \\\"08\\\"    => \\\"08\\\"\\n  // JSON    => parse if valid\\n  // String  => self\\n  function deserializeValue(value) {\\n    try {\\n      return value ?\\n        value == \\\"true\\\" ||\\n        ( value == \\\"false\\\" ? false :\\n          value == \\\"null\\\" ? null :\\n          +value + \\\"\\\" == value ? +value :\\n          /^[\\\\[\\\\{]/.test(value) ? $.parseJSON(value) :\\n          value )\\n        : value\\n    } catch(e) {\\n      return value\\n    }\\n  }\\n\\n  $.type = type\\n  $.isFunction = isFunction\\n  $.isWindow = isWindow\\n  $.isArray = isArray\\n  $.isPlainObject = isPlainObject\\n\\n  $.isEmptyObject = function(obj) {\\n    var name\\n    for (name in obj) return false\\n    return true\\n  }\\n\\n  $.isNumeric = function(val) {\\n    var num = Number(val), type = typeof val\\n    return val != null && type != 'boolean' &&\\n      (type != 'string' || val.length) &&\\n      !isNaN(num) && isFinite(num) || false\\n  }\\n\\n  $.inArray = function(elem, array, i){\\n    return emptyArray.indexOf.call(array, elem, i)\\n  }\\n\\n  $.camelCase = camelize\\n  $.trim = function(str) {\\n    return str == null ? \\\"\\\" : String.prototype.trim.call(str)\\n  }\\n\\n  // plugin compatibility\\n  $.uuid = 0\\n  $.support = { }\\n  $.expr = { }\\n  $.noop = function() {}\\n\\n  $.map = function(elements, callback){\\n    var value, values = [], i, key\\n    if (likeArray(elements))\\n      for (i = 0; i < elements.length; i++) {\\n        value = callback(elements[i], i)\\n        if (value != null) values.push(value)\\n      }\\n    else\\n      for (key in elements) {\\n        value = callback(elements[key], key)\\n        if (value != null) values.push(value)\\n      }\\n    return flatten(values)\\n  }\\n\\n  $.each = function(elements, callback){\\n    var i, key\\n    if (likeArray(elements)) {\\n      for (i = 0; i < elements.length; i++)\\n        if (callback.call(elements[i], i, elements[i]) === false) return elements\\n    } else {\\n      for (key in elements)\\n        if (callback.call(elements[key], key, elements[key]) === false) return elements\\n    }\\n\\n    return elements\\n  }\\n\\n  $.grep = function(elements, callback){\\n    return filter.call(elements, callback)\\n  }\\n\\n  if (window.JSON) $.parseJSON = JSON.parse\\n\\n  // Populate the class2type map\\n  $.each(\\\"Boolean Number String Function Array Date RegExp Object Error\\\".split(\\\" \\\"), function(i, name) {\\n    class2type[ \\\"[object \\\" + name + \\\"]\\\" ] = name.toLowerCase()\\n  })\\n\\n  // Define methods that will be available on all\\n  // Zepto collections\\n  $.fn = {\\n    constructor: zepto.Z,\\n    length: 0,\\n\\n    // Because a collection acts like an array\\n    // copy over these useful array functions.\\n    forEach: emptyArray.forEach,\\n    reduce: emptyArray.reduce,\\n    push: emptyArray.push,\\n    sort: emptyArray.sort,\\n    splice: emptyArray.splice,\\n    indexOf: emptyArray.indexOf,\\n    concat: function(){\\n      var i, value, args = []\\n      for (i = 0; i < arguments.length; i++) {\\n        value = arguments[i]\\n        args[i] = zepto.isZ(value) ? value.toArray() : value\\n      }\\n      return concat.apply(zepto.isZ(this) ? this.toArray() : this, args)\\n    },\\n\\n    // `map` and `slice` in the jQuery API work differently\\n    // from their array counterparts\\n    map: function(fn){\\n      return $($.map(this, function(el, i){ return fn.call(el, i, el) }))\\n    },\\n    slice: function(){\\n      return $(slice.apply(this, arguments))\\n    },\\n\\n    ready: function(callback){\\n      // need to check if document.body exists for IE as that browser reports\\n      // document ready when it hasn't yet created the body element\\n      if (readyRE.test(document.readyState) && document.body) callback($)\\n      else document.addEventListener('DOMContentLoaded', function(){ callback($) }, false)\\n      return this\\n    },\\n    get: function(idx){\\n      return idx === undefined ? slice.call(this) : this[idx >= 0 ? idx : idx + this.length]\\n    },\\n    toArray: function(){ return this.get() },\\n    size: function(){\\n      return this.length\\n    },\\n    remove: function(){\\n      return this.each(function(){\\n        if (this.parentNode != null)\\n          this.parentNode.removeChild(this)\\n      })\\n    },\\n    each: function(callback){\\n      emptyArray.every.call(this, function(el, idx){\\n        return callback.call(el, idx, el) !== false\\n      })\\n      return this\\n    },\\n    filter: function(selector){\\n      if (isFunction(selector)) return this.not(this.not(selector))\\n      return $(filter.call(this, function(element){\\n        return zepto.matches(element, selector)\\n      }))\\n    },\\n    add: function(selector,context){\\n      return $(uniq(this.concat($(selector,context))))\\n    },\\n    is: function(selector){\\n      return this.length > 0 && zepto.matches(this[0], selector)\\n    },\\n    not: function(selector){\\n      var nodes=[]\\n      if (isFunction(selector) && selector.call !== undefined)\\n        this.each(function(idx){\\n          if (!selector.call(this,idx)) nodes.push(this)\\n        })\\n      else {\\n        var excludes = typeof selector == 'string' ? this.filter(selector) :\\n          (likeArray(selector) && isFunction(selector.item)) ? slice.call(selector) : $(selector)\\n        this.forEach(function(el){\\n          if (excludes.indexOf(el) < 0) nodes.push(el)\\n        })\\n      }\\n      return $(nodes)\\n    },\\n    has: function(selector){\\n      return this.filter(function(){\\n        return isObject(selector) ?\\n          $.contains(this, selector) :\\n          $(this).find(selector).size()\\n      })\\n    },\\n    eq: function(idx){\\n      return idx === -1 ? this.slice(idx) : this.slice(idx, + idx + 1)\\n    },\\n    first: function(){\\n      var el = this[0]\\n      return el && !isObject(el) ? el : $(el)\\n    },\\n    last: function(){\\n      var el = this[this.length - 1]\\n      return el && !isObject(el) ? el : $(el)\\n    },\\n    find: function(selector){\\n      var result, $this = this\\n      if (!selector) result = $()\\n      else if (typeof selector == 'object')\\n        result = $(selector).filter(function(){\\n          var node = this\\n          return emptyArray.some.call($this, function(parent){\\n            return $.contains(parent, node)\\n          })\\n        })\\n      else if (this.length == 1) result = $(zepto.qsa(this[0], selector))\\n      else result = this.map(function(){ return zepto.qsa(this, selector) })\\n      return result\\n    },\\n    closest: function(selector, context){\\n      var nodes = [], collection = typeof selector == 'object' && $(selector)\\n      this.each(function(_, node){\\n        while (node && !(collection ? collection.indexOf(node) >= 0 : zepto.matches(node, selector)))\\n          node = node !== context && !isDocument(node) && node.parentNode\\n        if (node && nodes.indexOf(node) < 0) nodes.push(node)\\n      })\\n      return $(nodes)\\n    },\\n    parents: function(selector){\\n      var ancestors = [], nodes = this\\n      while (nodes.length > 0)\\n        nodes = $.map(nodes, function(node){\\n          if ((node = node.parentNode) && !isDocument(node) && ancestors.indexOf(node) < 0) {\\n            ancestors.push(node)\\n            return node\\n          }\\n        })\\n      return filtered(ancestors, selector)\\n    },\\n    parent: function(selector){\\n      return filtered(uniq(this.pluck('parentNode')), selector)\\n    },\\n    children: function(selector){\\n      return filtered(this.map(function(){ return children(this) }), selector)\\n    },\\n    contents: function() {\\n      return this.map(function() { return this.contentDocument || slice.call(this.childNodes) })\\n    },\\n    siblings: function(selector){\\n      return filtered(this.map(function(i, el){\\n        return filter.call(children(el.parentNode), function(child){ return child!==el })\\n      }), selector)\\n    },\\n    empty: function(){\\n      return this.each(function(){ this.innerHTML = '' })\\n    },\\n    // `pluck` is borrowed from Prototype.js\\n    pluck: function(property){\\n      return $.map(this, function(el){ return el[property] })\\n    },\\n    show: function(){\\n      return this.each(function(){\\n        this.style.display == \\\"none\\\" && (this.style.display = '')\\n        if (getComputedStyle(this, '').getPropertyValue(\\\"display\\\") == \\\"none\\\")\\n          this.style.display = defaultDisplay(this.nodeName)\\n      })\\n    },\\n    replaceWith: function(newContent){\\n      return this.before(newContent).remove()\\n    },\\n    wrap: function(structure){\\n      var func = isFunction(structure)\\n      if (this[0] && !func)\\n        var dom   = $(structure).get(0),\\n            clone = dom.parentNode || this.length > 1\\n\\n      return this.each(function(index){\\n        $(this).wrapAll(\\n          func ? structure.call(this, index) :\\n            clone ? dom.cloneNode(true) : dom\\n        )\\n      })\\n    },\\n    wrapAll: function(structure){\\n      if (this[0]) {\\n        $(this[0]).before(structure = $(structure))\\n        var children\\n        // drill down to the inmost element\\n        while ((children = structure.children()).length) structure = children.first()\\n        $(structure).append(this)\\n      }\\n      return this\\n    },\\n    wrapInner: function(structure){\\n      var func = isFunction(structure)\\n      return this.each(function(index){\\n        var self = $(this), contents = self.contents(),\\n            dom  = func ? structure.call(this, index) : structure\\n        contents.length ? contents.wrapAll(dom) : self.append(dom)\\n      })\\n    },\\n    unwrap: function(){\\n      this.parent().each(function(){\\n        $(this).replaceWith($(this).children())\\n      })\\n      return this\\n    },\\n    clone: function(){\\n      return this.map(function(){ return this.cloneNode(true) })\\n    },\\n    hide: function(){\\n      return this.css(\\\"display\\\", \\\"none\\\")\\n    },\\n    toggle: function(setting){\\n      return this.each(function(){\\n        var el = $(this)\\n        ;(setting === undefined ? el.css(\\\"display\\\") == \\\"none\\\" : setting) ? el.show() : el.hide()\\n      })\\n    },\\n    prev: function(selector){ return $(this.pluck('previousElementSibling')).filter(selector || '*') },\\n    next: function(selector){ return $(this.pluck('nextElementSibling')).filter(selector || '*') },\\n    html: function(html){\\n      return 0 in arguments ?\\n        this.each(function(idx){\\n          var originHtml = this.innerHTML\\n          $(this).empty().append( funcArg(this, html, idx, originHtml) )\\n        }) :\\n        (0 in this ? this[0].innerHTML : null)\\n    },\\n    text: function(text){\\n      return 0 in arguments ?\\n        this.each(function(idx){\\n          var newText = funcArg(this, text, idx, this.textContent)\\n          this.textContent = newText == null ? '' : ''+newText\\n        }) :\\n        (0 in this ? this.pluck('textContent').join(\\\"\\\") : null)\\n    },\\n    attr: function(name, value){\\n      var result\\n      return (typeof name == 'string' && !(1 in arguments)) ?\\n        (0 in this && this[0].nodeType == 1 && (result = this[0].getAttribute(name)) != null ? result : undefined) :\\n        this.each(function(idx){\\n          if (this.nodeType !== 1) return\\n          if (isObject(name)) for (key in name) setAttribute(this, key, name[key])\\n          else setAttribute(this, name, funcArg(this, value, idx, this.getAttribute(name)))\\n        })\\n    },\\n    removeAttr: function(name){\\n      return this.each(function(){ this.nodeType === 1 && name.split(' ').forEach(function(attribute){\\n        setAttribute(this, attribute)\\n      }, this)})\\n    },\\n    prop: function(name, value){\\n      name = propMap[name] || name\\n      return (1 in arguments) ?\\n        this.each(function(idx){\\n          this[name] = funcArg(this, value, idx, this[name])\\n        }) :\\n        (this[0] && this[0][name])\\n    },\\n    removeProp: function(name){\\n      name = propMap[name] || name\\n      return this.each(function(){ delete this[name] })\\n    },\\n    data: function(name, value){\\n      var attrName = 'data-' + name.replace(capitalRE, '-$1').toLowerCase()\\n\\n      var data = (1 in arguments) ?\\n        this.attr(attrName, value) :\\n        this.attr(attrName)\\n\\n      return data !== null ? deserializeValue(data) : undefined\\n    },\\n    val: function(value){\\n      if (0 in arguments) {\\n        if (value == null) value = \\\"\\\"\\n        return this.each(function(idx){\\n          this.value = funcArg(this, value, idx, this.value)\\n        })\\n      } else {\\n        return this[0] && (this[0].multiple ?\\n           $(this[0]).find('option').filter(function(){ return this.selected }).pluck('value') :\\n           this[0].value)\\n      }\\n    },\\n    offset: function(coordinates){\\n      if (coordinates) return this.each(function(index){\\n        var $this = $(this),\\n            coords = funcArg(this, coordinates, index, $this.offset()),\\n            parentOffset = $this.offsetParent().offset(),\\n            props = {\\n              top:  coords.top  - parentOffset.top,\\n              left: coords.left - parentOffset.left\\n            }\\n\\n        if ($this.css('position') == 'static') props['position'] = 'relative'\\n        $this.css(props)\\n      })\\n      if (!this.length) return null\\n      if (document.documentElement !== this[0] && !$.contains(document.documentElement, this[0]))\\n        return {top: 0, left: 0}\\n      var obj = this[0].getBoundingClientRect()\\n      return {\\n        left: obj.left + window.pageXOffset,\\n        top: obj.top + window.pageYOffset,\\n        width: Math.round(obj.width),\\n        height: Math.round(obj.height)\\n      }\\n    },\\n    css: function(property, value){\\n      if (arguments.length < 2) {\\n        var element = this[0]\\n        if (typeof property == 'string') {\\n          if (!element) return\\n          return element.style[camelize(property)] || getComputedStyle(element, '').getPropertyValue(property)\\n        } else if (isArray(property)) {\\n          if (!element) return\\n          var props = {}\\n          var computedStyle = getComputedStyle(element, '')\\n          $.each(property, function(_, prop){\\n            props[prop] = (element.style[camelize(prop)] || computedStyle.getPropertyValue(prop))\\n          })\\n          return props\\n        }\\n      }\\n\\n      var css = ''\\n      if (type(property) == 'string') {\\n        if (!value && value !== 0)\\n          this.each(function(){ this.style.removeProperty(dasherize(property)) })\\n        else\\n          css = dasherize(property) + \\\":\\\" + maybeAddPx(property, value)\\n      } else {\\n        for (key in property)\\n          if (!property[key] && property[key] !== 0)\\n            this.each(function(){ this.style.removeProperty(dasherize(key)) })\\n          else\\n            css += dasherize(key) + ':' + maybeAddPx(key, property[key]) + ';'\\n      }\\n\\n      return this.each(function(){ this.style.cssText += ';' + css })\\n    },\\n    index: function(element){\\n      return element ? this.indexOf($(element)[0]) : this.parent().children().indexOf(this[0])\\n    },\\n    hasClass: function(name){\\n      if (!name) return false\\n      return emptyArray.some.call(this, function(el){\\n        return this.test(className(el))\\n      }, classRE(name))\\n    },\\n    addClass: function(name){\\n      if (!name) return this\\n      return this.each(function(idx){\\n        if (!('className' in this)) return\\n        classList = []\\n        var cls = className(this), newName = funcArg(this, name, idx, cls)\\n        newName.split(/\\\\s+/g).forEach(function(klass){\\n          if (!$(this).hasClass(klass)) classList.push(klass)\\n        }, this)\\n        classList.length && className(this, cls + (cls ? \\\" \\\" : \\\"\\\") + classList.join(\\\" \\\"))\\n      })\\n    },\\n    removeClass: function(name){\\n      return this.each(function(idx){\\n        if (!('className' in this)) return\\n        if (name === undefined) return className(this, '')\\n        classList = className(this)\\n        funcArg(this, name, idx, classList).split(/\\\\s+/g).forEach(function(klass){\\n          classList = classList.replace(classRE(klass), \\\" \\\")\\n        })\\n        className(this, classList.trim())\\n      })\\n    },\\n    toggleClass: function(name, when){\\n      if (!name) return this\\n      return this.each(function(idx){\\n        var $this = $(this), names = funcArg(this, name, idx, className(this))\\n        names.split(/\\\\s+/g).forEach(function(klass){\\n          (when === undefined ? !$this.hasClass(klass) : when) ?\\n            $this.addClass(klass) : $this.removeClass(klass)\\n        })\\n      })\\n    },\\n    scrollTop: function(value){\\n      if (!this.length) return\\n      var hasScrollTop = 'scrollTop' in this[0]\\n      if (value === undefined) return hasScrollTop ? this[0].scrollTop : this[0].pageYOffset\\n      return this.each(hasScrollTop ?\\n        function(){ this.scrollTop = value } :\\n        function(){ this.scrollTo(this.scrollX, value) })\\n    },\\n    scrollLeft: function(value){\\n      if (!this.length) return\\n      var hasScrollLeft = 'scrollLeft' in this[0]\\n      if (value === undefined) return hasScrollLeft ? this[0].scrollLeft : this[0].pageXOffset\\n      return this.each(hasScrollLeft ?\\n        function(){ this.scrollLeft = value } :\\n        function(){ this.scrollTo(value, this.scrollY) })\\n    },\\n    position: function() {\\n      if (!this.length) return\\n\\n      var elem = this[0],\\n        // Get *real* offsetParent\\n        offsetParent = this.offsetParent(),\\n        // Get correct offsets\\n        offset       = this.offset(),\\n        parentOffset = rootNodeRE.test(offsetParent[0].nodeName) ? { top: 0, left: 0 } : offsetParent.offset()\\n\\n      // Subtract element margins\\n      // note: when an element has margin: auto the offsetLeft and marginLeft\\n      // are the same in Safari causing offset.left to incorrectly be 0\\n      offset.top  -= parseFloat( $(elem).css('margin-top') ) || 0\\n      offset.left -= parseFloat( $(elem).css('margin-left') ) || 0\\n\\n      // Add offsetParent borders\\n      parentOffset.top  += parseFloat( $(offsetParent[0]).css('border-top-width') ) || 0\\n      parentOffset.left += parseFloat( $(offsetParent[0]).css('border-left-width') ) || 0\\n\\n      // Subtract the two offsets\\n      return {\\n        top:  offset.top  - parentOffset.top,\\n        left: offset.left - parentOffset.left\\n      }\\n    },\\n    offsetParent: function() {\\n      return this.map(function(){\\n        var parent = this.offsetParent || document.body\\n        while (parent && !rootNodeRE.test(parent.nodeName) && $(parent).css(\\\"position\\\") == \\\"static\\\")\\n          parent = parent.offsetParent\\n        return parent\\n      })\\n    }\\n  }\\n\\n  // for now\\n  $.fn.detach = $.fn.remove\\n\\n  // Generate the `width` and `height` functions\\n  ;['width', 'height'].forEach(function(dimension){\\n    var dimensionProperty =\\n      dimension.replace(/./, function(m){ return m[0].toUpperCase() })\\n\\n    $.fn[dimension] = function(value){\\n      var offset, el = this[0]\\n      if (value === undefined) return isWindow(el) ? el['inner' + dimensionProperty] :\\n        isDocument(el) ? el.documentElement['scroll' + dimensionProperty] :\\n        (offset = this.offset()) && offset[dimension]\\n      else return this.each(function(idx){\\n        el = $(this)\\n        el.css(dimension, funcArg(this, value, idx, el[dimension]()))\\n      })\\n    }\\n  })\\n\\n  function traverseNode(node, fun) {\\n    fun(node)\\n    for (var i = 0, len = node.childNodes.length; i < len; i++)\\n      traverseNode(node.childNodes[i], fun)\\n  }\\n\\n  // Generate the `after`, `prepend`, `before`, `append`,\\n  // `insertAfter`, `insertBefore`, `appendTo`, and `prependTo` methods.\\n  adjacencyOperators.forEach(function(operator, operatorIndex) {\\n    var inside = operatorIndex % 2 //=> prepend, append\\n\\n    $.fn[operator] = function(){\\n      // arguments can be nodes, arrays of nodes, Zepto objects and HTML strings\\n      var argType, nodes = $.map(arguments, function(arg) {\\n            var arr = []\\n            argType = type(arg)\\n            if (argType == \\\"array\\\") {\\n              arg.forEach(function(el) {\\n                if (el.nodeType !== undefined) return arr.push(el)\\n                else if ($.zepto.isZ(el)) return arr = arr.concat(el.get())\\n                arr = arr.concat(zepto.fragment(el))\\n              })\\n              return arr\\n            }\\n            return argType == \\\"object\\\" || arg == null ?\\n              arg : zepto.fragment(arg)\\n          }),\\n          parent, copyByClone = this.length > 1\\n      if (nodes.length < 1) return this\\n\\n      return this.each(function(_, target){\\n        parent = inside ? target : target.parentNode\\n\\n        // convert all methods to a \\\"before\\\" operation\\n        target = operatorIndex == 0 ? target.nextSibling :\\n                 operatorIndex == 1 ? target.firstChild :\\n                 operatorIndex == 2 ? target :\\n                 null\\n\\n        var parentInDocument = $.contains(document.documentElement, parent)\\n\\n        nodes.forEach(function(node){\\n          if (copyByClone) node = node.cloneNode(true)\\n          else if (!parent) return $(node).remove()\\n\\n          parent.insertBefore(node, target)\\n          if (parentInDocument) traverseNode(node, function(el){\\n            if (el.nodeName != null && el.nodeName.toUpperCase() === 'SCRIPT' &&\\n               (!el.type || el.type === 'text/javascript') && !el.src){\\n              var target = el.ownerDocument ? el.ownerDocument.defaultView : window\\n              target['eval'].call(target, el.innerHTML)\\n            }\\n          })\\n        })\\n      })\\n    }\\n\\n    // after    => insertAfter\\n    // prepend  => prependTo\\n    // before   => insertBefore\\n    // append   => appendTo\\n    $.fn[inside ? operator+'To' : 'insert'+(operatorIndex ? 'Before' : 'After')] = function(html){\\n      $(html)[operator](this)\\n      return this\\n    }\\n  })\\n\\n  zepto.Z.prototype = Z.prototype = $.fn\\n\\n  // Export internal API functions in the `$.zepto` namespace\\n  zepto.uniq = uniq\\n  zepto.deserializeValue = deserializeValue\\n  $.zepto = zepto\\n\\n  return $\\n})()\\n\\nwindow.Zepto = Zepto\\nwindow.$ === undefined && (window.$ = Zepto)\\n\\n;(function($){\\n  var _zid = 1, undefined,\\n      slice = Array.prototype.slice,\\n      isFunction = $.isFunction,\\n      isString = function(obj){ return typeof obj == 'string' },\\n      handlers = {},\\n      specialEvents={},\\n      focusinSupported = 'onfocusin' in window,\\n      focus = { focus: 'focusin', blur: 'focusout' },\\n      hover = { mouseenter: 'mouseover', mouseleave: 'mouseout' }\\n\\n  specialEvents.click = specialEvents.mousedown = specialEvents.mouseup = specialEvents.mousemove = 'MouseEvents'\\n\\n  function zid(element) {\\n    return element._zid || (element._zid = _zid++)\\n  }\\n  function findHandlers(element, event, fn, selector) {\\n    event = parse(event)\\n    if (event.ns) var matcher = matcherFor(event.ns)\\n    return (handlers[zid(element)] || []).filter(function(handler) {\\n      return handler\\n        && (!event.e  || handler.e == event.e)\\n        && (!event.ns || matcher.test(handler.ns))\\n        && (!fn       || zid(handler.fn) === zid(fn))\\n        && (!selector || handler.sel == selector)\\n    })\\n  }\\n  function parse(event) {\\n    var parts = ('' + event).split('.')\\n    return {e: parts[0], ns: parts.slice(1).sort().join(' ')}\\n  }\\n  function matcherFor(ns) {\\n    return new RegExp('(?:^| )' + ns.replace(' ', ' .* ?') + '(?: |$)')\\n  }\\n\\n  function eventCapture(handler, captureSetting) {\\n    return handler.del &&\\n      (!focusinSupported && (handler.e in focus)) ||\\n      !!captureSetting\\n  }\\n\\n  function realEvent(type) {\\n    return hover[type] || (focusinSupported && focus[type]) || type\\n  }\\n\\n  function add(element, events, fn, data, selector, delegator, capture){\\n    var id = zid(element), set = (handlers[id] || (handlers[id] = []))\\n    events.split(/\\\\s/).forEach(function(event){\\n      if (event == 'ready') return $(document).ready(fn)\\n      var handler   = parse(event)\\n      handler.fn    = fn\\n      handler.sel   = selector\\n      // emulate mouseenter, mouseleave\\n      if (handler.e in hover) fn = function(e){\\n        var related = e.relatedTarget\\n        if (!related || (related !== this && !$.contains(this, related)))\\n          return handler.fn.apply(this, arguments)\\n      }\\n      handler.del   = delegator\\n      var callback  = delegator || fn\\n      handler.proxy = function(e){\\n        e = compatible(e)\\n        if (e.isImmediatePropagationStopped()) return\\n        e.data = data\\n        var result = callback.apply(element, e._args == undefined ? [e] : [e].concat(e._args))\\n        if (result === false) e.preventDefault(), e.stopPropagation()\\n        return result\\n      }\\n      handler.i = set.length\\n      set.push(handler)\\n      if ('addEventListener' in element)\\n        element.addEventListener(realEvent(handler.e), handler.proxy, eventCapture(handler, capture))\\n    })\\n  }\\n  function remove(element, events, fn, selector, capture){\\n    var id = zid(element)\\n    ;(events || '').split(/\\\\s/).forEach(function(event){\\n      findHandlers(element, event, fn, selector).forEach(function(handler){\\n        delete handlers[id][handler.i]\\n      if ('removeEventListener' in element)\\n        element.removeEventListener(realEvent(handler.e), handler.proxy, eventCapture(handler, capture))\\n      })\\n    })\\n  }\\n\\n  $.event = { add: add, remove: remove }\\n\\n  $.proxy = function(fn, context) {\\n    var args = (2 in arguments) && slice.call(arguments, 2)\\n    if (isFunction(fn)) {\\n      var proxyFn = function(){ return fn.apply(context, args ? args.concat(slice.call(arguments)) : arguments) }\\n      proxyFn._zid = zid(fn)\\n      return proxyFn\\n    } else if (isString(context)) {\\n      if (args) {\\n        args.unshift(fn[context], fn)\\n        return $.proxy.apply(null, args)\\n      } else {\\n        return $.proxy(fn[context], fn)\\n      }\\n    } else {\\n      throw new TypeError(\\\"expected function\\\")\\n    }\\n  }\\n\\n  $.fn.bind = function(event, data, callback){\\n    return this.on(event, data, callback)\\n  }\\n  $.fn.unbind = function(event, callback){\\n    return this.off(event, callback)\\n  }\\n  $.fn.one = function(event, selector, data, callback){\\n    return this.on(event, selector, data, callback, 1)\\n  }\\n\\n  var returnTrue = function(){return true},\\n      returnFalse = function(){return false},\\n      ignoreProperties = /^([A-Z]|returnValue$|layer[XY]$|webkitMovement[XY]$)/,\\n      eventMethods = {\\n        preventDefault: 'isDefaultPrevented',\\n        stopImmediatePropagation: 'isImmediatePropagationStopped',\\n        stopPropagation: 'isPropagationStopped'\\n      }\\n\\n  function compatible(event, source) {\\n    if (source || !event.isDefaultPrevented) {\\n      source || (source = event)\\n\\n      $.each(eventMethods, function(name, predicate) {\\n        var sourceMethod = source[name]\\n        event[name] = function(){\\n          this[predicate] = returnTrue\\n          return sourceMethod && sourceMethod.apply(source, arguments)\\n        }\\n        event[predicate] = returnFalse\\n      })\\n\\n      event.timeStamp || (event.timeStamp = Date.now())\\n\\n      if (source.defaultPrevented !== undefined ? source.defaultPrevented :\\n          'returnValue' in source ? source.returnValue === false :\\n          source.getPreventDefault && source.getPreventDefault())\\n        event.isDefaultPrevented = returnTrue\\n    }\\n    return event\\n  }\\n\\n  function createProxy(event) {\\n    var key, proxy = { originalEvent: event }\\n    for (key in event)\\n      if (!ignoreProperties.test(key) && event[key] !== undefined) proxy[key] = event[key]\\n\\n    return compatible(proxy, event)\\n  }\\n\\n  $.fn.delegate = function(selector, event, callback){\\n    return this.on(event, selector, callback)\\n  }\\n  $.fn.undelegate = function(selector, event, callback){\\n    return this.off(event, selector, callback)\\n  }\\n\\n  $.fn.live = function(event, callback){\\n    $(document.body).delegate(this.selector, event, callback)\\n    return this\\n  }\\n  $.fn.die = function(event, callback){\\n    $(document.body).undelegate(this.selector, event, callback)\\n    return this\\n  }\\n\\n  $.fn.on = function(event, selector, data, callback, one){\\n    var autoRemove, delegator, $this = this\\n    if (event && !isString(event)) {\\n      $.each(event, function(type, fn){\\n        $this.on(type, selector, data, fn, one)\\n      })\\n      return $this\\n    }\\n\\n    if (!isString(selector) && !isFunction(callback) && callback !== false)\\n      callback = data, data = selector, selector = undefined\\n    if (callback === undefined || data === false)\\n      callback = data, data = undefined\\n\\n    if (callback === false) callback = returnFalse\\n\\n    return $this.each(function(_, element){\\n      if (one) autoRemove = function(e){\\n        remove(element, e.type, callback)\\n        return callback.apply(this, arguments)\\n      }\\n\\n      if (selector) delegator = function(e){\\n        var evt, match = $(e.target).closest(selector, element).get(0)\\n        if (match && match !== element) {\\n          evt = $.extend(createProxy(e), {currentTarget: match, liveFired: element})\\n          return (autoRemove || callback).apply(match, [evt].concat(slice.call(arguments, 1)))\\n        }\\n      }\\n\\n      add(element, event, callback, data, selector, delegator || autoRemove)\\n    })\\n  }\\n  $.fn.off = function(event, selector, callback){\\n    var $this = this\\n    if (event && !isString(event)) {\\n      $.each(event, function(type, fn){\\n        $this.off(type, selector, fn)\\n      })\\n      return $this\\n    }\\n\\n    if (!isString(selector) && !isFunction(callback) && callback !== false)\\n      callback = selector, selector = undefined\\n\\n    if (callback === false) callback = returnFalse\\n\\n    return $this.each(function(){\\n      remove(this, event, callback, selector)\\n    })\\n  }\\n\\n  $.fn.trigger = function(event, args){\\n    event = (isString(event) || $.isPlainObject(event)) ? $.Event(event) : compatible(event)\\n    event._args = args\\n    return this.each(function(){\\n      // handle focus(), blur() by calling them directly\\n      if (event.type in focus && typeof this[event.type] == \\\"function\\\") this[event.type]()\\n      // items in the collection might not be DOM elements\\n      else if ('dispatchEvent' in this) this.dispatchEvent(event)\\n      else $(this).triggerHandler(event, args)\\n    })\\n  }\\n\\n  // triggers event handlers on current element just as if an event occurred,\\n  // doesn't trigger an actual event, doesn't bubble\\n  $.fn.triggerHandler = function(event, args){\\n    var e, result\\n    this.each(function(i, element){\\n      e = createProxy(isString(event) ? $.Event(event) : event)\\n      e._args = args\\n      e.target = element\\n      $.each(findHandlers(element, event.type || event), function(i, handler){\\n        result = handler.proxy(e)\\n        if (e.isImmediatePropagationStopped()) return false\\n      })\\n    })\\n    return result\\n  }\\n\\n  // shortcut methods for `.bind(event, fn)` for each event type\\n  ;('focusin focusout focus blur load resize scroll unload click dblclick '+\\n  'mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave '+\\n  'change select keydown keypress keyup error').split(' ').forEach(function(event) {\\n    $.fn[event] = function(callback) {\\n      return (0 in arguments) ?\\n        this.bind(event, callback) :\\n        this.trigger(event)\\n    }\\n  })\\n\\n  $.Event = function(type, props) {\\n    if (!isString(type)) props = type, type = props.type\\n    var event = document.createEvent(specialEvents[type] || 'Events'), bubbles = true\\n    if (props) for (var name in props) (name == 'bubbles') ? (bubbles = !!props[name]) : (event[name] = props[name])\\n    event.initEvent(type, bubbles, true)\\n    return compatible(event)\\n  }\\n\\n})(Zepto)\\n\\n;(function($){\\n  var jsonpID = +new Date(),\\n      document = window.document,\\n      key,\\n      name,\\n      rscript = /<script\\\\b[^<]*(?:(?!<\\\\/script>)<[^<]*)*<\\\\/script>/gi,\\n      scriptTypeRE = /^(?:text|application)\\\\/javascript/i,\\n      xmlTypeRE = /^(?:text|application)\\\\/xml/i,\\n      jsonType = 'application/json',\\n      htmlType = 'text/html',\\n      blankRE = /^\\\\s*$/,\\n      originAnchor = document.createElement('a')\\n\\n  originAnchor.href = window.location.href\\n\\n  // trigger a custom event and return false if it was cancelled\\n  function triggerAndReturn(context, eventName, data) {\\n    var event = $.Event(eventName)\\n    $(context).trigger(event, data)\\n    return !event.isDefaultPrevented()\\n  }\\n\\n  // trigger an Ajax \\\"global\\\" event\\n  function triggerGlobal(settings, context, eventName, data) {\\n    if (settings.global) return triggerAndReturn(context || document, eventName, data)\\n  }\\n\\n  // Number of active Ajax requests\\n  $.active = 0\\n\\n  function ajaxStart(settings) {\\n    if (settings.global && $.active++ === 0) triggerGlobal(settings, null, 'ajaxStart')\\n  }\\n  function ajaxStop(settings) {\\n    if (settings.global && !(--$.active)) triggerGlobal(settings, null, 'ajaxStop')\\n  }\\n\\n  // triggers an extra global event \\\"ajaxBeforeSend\\\" that's like \\\"ajaxSend\\\" but cancelable\\n  function ajaxBeforeSend(xhr, settings) {\\n    var context = settings.context\\n    if (settings.beforeSend.call(context, xhr, settings) === false ||\\n        triggerGlobal(settings, context, 'ajaxBeforeSend', [xhr, settings]) === false)\\n      return false\\n\\n    triggerGlobal(settings, context, 'ajaxSend', [xhr, settings])\\n  }\\n  function ajaxSuccess(data, xhr, settings, deferred) {\\n    var context = settings.context, status = 'success'\\n    settings.success.call(context, data, status, xhr)\\n    if (deferred) deferred.resolveWith(context, [data, status, xhr])\\n    triggerGlobal(settings, context, 'ajaxSuccess', [xhr, settings, data])\\n    ajaxComplete(status, xhr, settings)\\n  }\\n  // type: \\\"timeout\\\", \\\"error\\\", \\\"abort\\\", \\\"parsererror\\\"\\n  function ajaxError(error, type, xhr, settings, deferred) {\\n    var context = settings.context\\n    settings.error.call(context, xhr, type, error)\\n    if (deferred) deferred.rejectWith(context, [xhr, type, error])\\n    triggerGlobal(settings, context, 'ajaxError', [xhr, settings, error || type])\\n    ajaxComplete(type, xhr, settings)\\n  }\\n  // status: \\\"success\\\", \\\"notmodified\\\", \\\"error\\\", \\\"timeout\\\", \\\"abort\\\", \\\"parsererror\\\"\\n  function ajaxComplete(status, xhr, settings) {\\n    var context = settings.context\\n    settings.complete.call(context, xhr, status)\\n    triggerGlobal(settings, context, 'ajaxComplete', [xhr, settings])\\n    ajaxStop(settings)\\n  }\\n\\n  function ajaxDataFilter(data, type, settings) {\\n    if (settings.dataFilter == empty) return data\\n    var context = settings.context\\n    return settings.dataFilter.call(context, data, type)\\n  }\\n\\n  // Empty function, used as default callback\\n  function empty() {}\\n\\n  $.ajaxJSONP = function(options, deferred){\\n    if (!('type' in options)) return $.ajax(options)\\n\\n    var _callbackName = options.jsonpCallback,\\n      callbackName = ($.isFunction(_callbackName) ?\\n        _callbackName() : _callbackName) || ('Zepto' + (jsonpID++)),\\n      script = document.createElement('script'),\\n      originalCallback = window[callbackName],\\n      responseData,\\n      abort = function(errorType) {\\n        $(script).triggerHandler('error', errorType || 'abort')\\n      },\\n      xhr = { abort: abort }, abortTimeout\\n\\n    if (deferred) deferred.promise(xhr)\\n\\n    $(script).on('load error', function(e, errorType){\\n      clearTimeout(abortTimeout)\\n      $(script).off().remove()\\n\\n      if (e.type == 'error' || !responseData) {\\n        ajaxError(null, errorType || 'error', xhr, options, deferred)\\n      } else {\\n        ajaxSuccess(responseData[0], xhr, options, deferred)\\n      }\\n\\n      window[callbackName] = originalCallback\\n      if (responseData && $.isFunction(originalCallback))\\n        originalCallback(responseData[0])\\n\\n      originalCallback = responseData = undefined\\n    })\\n\\n    if (ajaxBeforeSend(xhr, options) === false) {\\n      abort('abort')\\n      return xhr\\n    }\\n\\n    window[callbackName] = function(){\\n      responseData = arguments\\n    }\\n\\n    script.src = options.url.replace(/\\\\?(.+)=\\\\?/, '?$1=' + callbackName)\\n    document.head.appendChild(script)\\n\\n    if (options.timeout > 0) abortTimeout = setTimeout(function(){\\n      abort('timeout')\\n    }, options.timeout)\\n\\n    return xhr\\n  }\\n\\n  $.ajaxSettings = {\\n    // Default type of request\\n    type: 'GET',\\n    // Callback that is executed before request\\n    beforeSend: empty,\\n    // Callback that is executed if the request succeeds\\n    success: empty,\\n    // Callback that is executed the the server drops error\\n    error: empty,\\n    // Callback that is executed on request complete (both: error and success)\\n    complete: empty,\\n    // The context for the callbacks\\n    context: null,\\n    // Whether to trigger \\\"global\\\" Ajax events\\n    global: true,\\n    // Transport\\n    xhr: function () {\\n      return new window.XMLHttpRequest()\\n    },\\n    // MIME types mapping\\n    // IIS returns Javascript as \\\"application/x-javascript\\\"\\n    accepts: {\\n      script: 'text/javascript, application/javascript, application/x-javascript',\\n      json:   jsonType,\\n      xml:    'application/xml, text/xml',\\n      html:   htmlType,\\n      text:   'text/plain'\\n    },\\n    // Whether the request is to another domain\\n    crossDomain: false,\\n    // Default timeout\\n    timeout: 0,\\n    // Whether data should be serialized to string\\n    processData: true,\\n    // Whether the browser should be allowed to cache GET responses\\n    cache: true,\\n    //Used to handle the raw response data of XMLHttpRequest.\\n    //This is a pre-filtering function to sanitize the response.\\n    //The sanitized response should be returned\\n    dataFilter: empty\\n  }\\n\\n  function mimeToDataType(mime) {\\n    if (mime) mime = mime.split(';', 2)[0]\\n    return mime && ( mime == htmlType ? 'html' :\\n      mime == jsonType ? 'json' :\\n      scriptTypeRE.test(mime) ? 'script' :\\n      xmlTypeRE.test(mime) && 'xml' ) || 'text'\\n  }\\n\\n  function appendQuery(url, query) {\\n    if (query == '') return url\\n    return (url + '&' + query).replace(/[&?]{1,2}/, '?')\\n  }\\n\\n  // serialize payload and append it to the URL for GET requests\\n  function serializeData(options) {\\n    if (options.processData && options.data && $.type(options.data) != \\\"string\\\")\\n      options.data = $.param(options.data, options.traditional)\\n    if (options.data && (!options.type || options.type.toUpperCase() == 'GET' || 'jsonp' == options.dataType))\\n      options.url = appendQuery(options.url, options.data), options.data = undefined\\n  }\\n\\n  $.ajax = function(options){\\n    var settings = $.extend({}, options || {}),\\n        deferred = $.Deferred && $.Deferred(),\\n        urlAnchor, hashIndex\\n    for (key in $.ajaxSettings) if (settings[key] === undefined) settings[key] = $.ajaxSettings[key]\\n\\n    ajaxStart(settings)\\n\\n    if (!settings.crossDomain) {\\n      urlAnchor = document.createElement('a')\\n      urlAnchor.href = settings.url\\n      // cleans up URL for .href (IE only), see https://github.com/madrobby/zepto/pull/1049\\n      urlAnchor.href = urlAnchor.href\\n      settings.crossDomain = (originAnchor.protocol + '//' + originAnchor.host) !== (urlAnchor.protocol + '//' + urlAnchor.host)\\n    }\\n\\n    if (!settings.url) settings.url = window.location.toString()\\n    if ((hashIndex = settings.url.indexOf('#')) > -1) settings.url = settings.url.slice(0, hashIndex)\\n    serializeData(settings)\\n\\n    var dataType = settings.dataType, hasPlaceholder = /\\\\?.+=\\\\?/.test(settings.url)\\n    if (hasPlaceholder) dataType = 'jsonp'\\n\\n    if (settings.cache === false || (\\n         (!options || options.cache !== true) &&\\n         ('script' == dataType || 'jsonp' == dataType)\\n        ))\\n      settings.url = appendQuery(settings.url, '_=' + Date.now())\\n\\n    if ('jsonp' == dataType) {\\n      if (!hasPlaceholder)\\n        settings.url = appendQuery(settings.url,\\n          settings.jsonp ? (settings.jsonp + '=?') : settings.jsonp === false ? '' : 'callback=?')\\n      return $.ajaxJSONP(settings, deferred)\\n    }\\n\\n    var mime = settings.accepts[dataType],\\n        headers = { },\\n        setHeader = function(name, value) { headers[name.toLowerCase()] = [name, value] },\\n        protocol = /^([\\\\w-]+:)\\\\/\\\\//.test(settings.url) ? RegExp.$1 : window.location.protocol,\\n        xhr = settings.xhr(),\\n        nativeSetHeader = xhr.setRequestHeader,\\n        abortTimeout\\n\\n    if (deferred) deferred.promise(xhr)\\n\\n    if (!settings.crossDomain) setHeader('X-Requested-With', 'XMLHttpRequest')\\n    setHeader('Accept', mime || '*/*')\\n    if (mime = settings.mimeType || mime) {\\n      if (mime.indexOf(',') > -1) mime = mime.split(',', 2)[0]\\n      xhr.overrideMimeType && xhr.overrideMimeType(mime)\\n    }\\n    if (settings.contentType || (settings.contentType !== false && settings.data && settings.type.toUpperCase() != 'GET'))\\n      setHeader('Content-Type', settings.contentType || 'application/x-www-form-urlencoded')\\n\\n    if (settings.headers) for (name in settings.headers) setHeader(name, settings.headers[name])\\n    xhr.setRequestHeader = setHeader\\n\\n    xhr.onreadystatechange = function(){\\n      if (xhr.readyState == 4) {\\n        xhr.onreadystatechange = empty\\n        clearTimeout(abortTimeout)\\n        var result, error = false\\n        if ((xhr.status >= 200 && xhr.status < 300) || xhr.status == 304 || (xhr.status == 0 && protocol == 'file:')) {\\n          dataType = dataType || mimeToDataType(settings.mimeType || xhr.getResponseHeader('content-type'))\\n\\n          if (xhr.responseType == 'arraybuffer' || xhr.responseType == 'blob')\\n            result = xhr.response\\n          else {\\n            result = xhr.responseText\\n\\n            try {\\n              // http://perfectionkills.com/global-eval-what-are-the-options/\\n              // sanitize response accordingly if data filter callback provided\\n              result = ajaxDataFilter(result, dataType, settings)\\n              if (dataType == 'script')    (1,eval)(result)\\n              else if (dataType == 'xml')  result = xhr.responseXML\\n              else if (dataType == 'json') result = blankRE.test(result) ? null : $.parseJSON(result)\\n            } catch (e) { error = e }\\n\\n            if (error) return ajaxError(error, 'parsererror', xhr, settings, deferred)\\n          }\\n\\n          ajaxSuccess(result, xhr, settings, deferred)\\n        } else {\\n          ajaxError(xhr.statusText || null, xhr.status ? 'error' : 'abort', xhr, settings, deferred)\\n        }\\n      }\\n    }\\n\\n    if (ajaxBeforeSend(xhr, settings) === false) {\\n      xhr.abort()\\n      ajaxError(null, 'abort', xhr, settings, deferred)\\n      return xhr\\n    }\\n\\n    var async = 'async' in settings ? settings.async : true\\n    xhr.open(settings.type, settings.url, async, settings.username, settings.password)\\n\\n    if (settings.xhrFields) for (name in settings.xhrFields) xhr[name] = settings.xhrFields[name]\\n\\n    for (name in headers) nativeSetHeader.apply(xhr, headers[name])\\n\\n    if (settings.timeout > 0) abortTimeout = setTimeout(function(){\\n        xhr.onreadystatechange = empty\\n        xhr.abort()\\n        ajaxError(null, 'timeout', xhr, settings, deferred)\\n      }, settings.timeout)\\n\\n    // avoid sending empty string (#319)\\n    xhr.send(settings.data ? settings.data : null)\\n    return xhr\\n  }\\n\\n  // handle optional data/success arguments\\n  function parseArguments(url, data, success, dataType) {\\n    if ($.isFunction(data)) dataType = success, success = data, data = undefined\\n    if (!$.isFunction(success)) dataType = success, success = undefined\\n    return {\\n      url: url\\n    , data: data\\n    , success: success\\n    , dataType: dataType\\n    }\\n  }\\n\\n  $.get = function(/* url, data, success, dataType */){\\n    return $.ajax(parseArguments.apply(null, arguments))\\n  }\\n\\n  $.post = function(/* url, data, success, dataType */){\\n    var options = parseArguments.apply(null, arguments)\\n    options.type = 'POST'\\n    return $.ajax(options)\\n  }\\n\\n  $.getJSON = function(/* url, data, success */){\\n    var options = parseArguments.apply(null, arguments)\\n    options.dataType = 'json'\\n    return $.ajax(options)\\n  }\\n\\n  $.fn.load = function(url, data, success){\\n    if (!this.length) return this\\n    var self = this, parts = url.split(/\\\\s/), selector,\\n        options = parseArguments(url, data, success),\\n        callback = options.success\\n    if (parts.length > 1) options.url = parts[0], selector = parts[1]\\n    options.success = function(response){\\n      self.html(selector ?\\n        $('<div>').html(response.replace(rscript, \\\"\\\")).find(selector)\\n        : response)\\n      callback && callback.apply(self, arguments)\\n    }\\n    $.ajax(options)\\n    return this\\n  }\\n\\n  var escape = encodeURIComponent\\n\\n  function serialize(params, obj, traditional, scope){\\n    var type, array = $.isArray(obj), hash = $.isPlainObject(obj)\\n    $.each(obj, function(key, value) {\\n      type = $.type(value)\\n      if (scope) key = traditional ? scope :\\n        scope + '[' + (hash || type == 'object' || type == 'array' ? key : '') + ']'\\n      // handle data in serializeArray() format\\n      if (!scope && array) params.add(value.name, value.value)\\n      // recurse into nested objects\\n      else if (type == \\\"array\\\" || (!traditional && type == \\\"object\\\"))\\n        serialize(params, value, traditional, key)\\n      else params.add(key, value)\\n    })\\n  }\\n\\n  $.param = function(obj, traditional){\\n    var params = []\\n    params.add = function(key, value) {\\n      if ($.isFunction(value)) value = value()\\n      if (value == null) value = \\\"\\\"\\n      this.push(escape(key) + '=' + escape(value))\\n    }\\n    serialize(params, obj, traditional)\\n    return params.join('&').replace(/%20/g, '+')\\n  }\\n})(Zepto)\\n\\n;(function($){\\n  $.fn.serializeArray = function() {\\n    var name, type, result = [],\\n      add = function(value) {\\n        if (value.forEach) return value.forEach(add)\\n        result.push({ name: name, value: value })\\n      }\\n    if (this[0]) $.each(this[0].elements, function(_, field){\\n      type = field.type, name = field.name\\n      if (name && field.nodeName.toLowerCase() != 'fieldset' &&\\n        !field.disabled && type != 'submit' && type != 'reset' && type != 'button' && type != 'file' &&\\n        ((type != 'radio' && type != 'checkbox') || field.checked))\\n          add($(field).val())\\n    })\\n    return result\\n  }\\n\\n  $.fn.serialize = function(){\\n    var result = []\\n    this.serializeArray().forEach(function(elm){\\n      result.push(encodeURIComponent(elm.name) + '=' + encodeURIComponent(elm.value))\\n    })\\n    return result.join('&')\\n  }\\n\\n  $.fn.submit = function(callback) {\\n    if (0 in arguments) this.bind('submit', callback)\\n    else if (this.length) {\\n      var event = $.Event('submit')\\n      this.eq(0).trigger(event)\\n      if (!event.isDefaultPrevented()) this.get(0).submit()\\n    }\\n    return this\\n  }\\n\\n})(Zepto)\\n\\n;(function(){\\n  // getComputedStyle shouldn't freak out when called\\n  // without a valid element as argument\\n  try {\\n    getComputedStyle(undefined)\\n  } catch(e) {\\n    var nativeGetComputedStyle = getComputedStyle\\n    window.getComputedStyle = function(element, pseudoElement){\\n      try {\\n        return nativeGetComputedStyle(element, pseudoElement)\\n      } catch(e) {\\n        return null\\n      }\\n    }\\n  }\\n})()\\n  return Zepto\\n}))\\n\"//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy96ZXB0by9kaXN0L3plcHRvLmpzP2Q3YTgiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSBcIi8qIFplcHRvIHYxLjIuMCAtIHplcHRvIGV2ZW50IGFqYXggZm9ybSBpZSAtIHplcHRvanMuY29tL2xpY2Vuc2UgKi9cXG4oZnVuY3Rpb24oZ2xvYmFsLCBmYWN0b3J5KSB7XFxuICBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKVxcbiAgICBkZWZpbmUoZnVuY3Rpb24oKSB7IHJldHVybiBmYWN0b3J5KGdsb2JhbCkgfSlcXG4gIGVsc2VcXG4gICAgZmFjdG9yeShnbG9iYWwpXFxufSh0aGlzLCBmdW5jdGlvbih3aW5kb3cpIHtcXG4gIHZhciBaZXB0byA9IChmdW5jdGlvbigpIHtcXG4gIHZhciB1bmRlZmluZWQsIGtleSwgJCwgY2xhc3NMaXN0LCBlbXB0eUFycmF5ID0gW10sIGNvbmNhdCA9IGVtcHR5QXJyYXkuY29uY2F0LCBmaWx0ZXIgPSBlbXB0eUFycmF5LmZpbHRlciwgc2xpY2UgPSBlbXB0eUFycmF5LnNsaWNlLFxcbiAgICBkb2N1bWVudCA9IHdpbmRvdy5kb2N1bWVudCxcXG4gICAgZWxlbWVudERpc3BsYXkgPSB7fSwgY2xhc3NDYWNoZSA9IHt9LFxcbiAgICBjc3NOdW1iZXIgPSB7ICdjb2x1bW4tY291bnQnOiAxLCAnY29sdW1ucyc6IDEsICdmb250LXdlaWdodCc6IDEsICdsaW5lLWhlaWdodCc6IDEsJ29wYWNpdHknOiAxLCAnei1pbmRleCc6IDEsICd6b29tJzogMSB9LFxcbiAgICBmcmFnbWVudFJFID0gL15cXFxccyo8KFxcXFx3K3whKVtePl0qPi8sXFxuICAgIHNpbmdsZVRhZ1JFID0gL148KFxcXFx3KylcXFxccypcXFxcLz8+KD86PFxcXFwvXFxcXDE+fCkkLyxcXG4gICAgdGFnRXhwYW5kZXJSRSA9IC88KD8hYXJlYXxicnxjb2x8ZW1iZWR8aHJ8aW1nfGlucHV0fGxpbmt8bWV0YXxwYXJhbSkoKFtcXFxcdzpdKylbXj5dKilcXFxcLz4vaWcsXFxuICAgIHJvb3ROb2RlUkUgPSAvXig/OmJvZHl8aHRtbCkkL2ksXFxuICAgIGNhcGl0YWxSRSA9IC8oW0EtWl0pL2csXFxuXFxuICAgIC8vIHNwZWNpYWwgYXR0cmlidXRlcyB0aGF0IHNob3VsZCBiZSBnZXQvc2V0IHZpYSBtZXRob2QgY2FsbHNcXG4gICAgbWV0aG9kQXR0cmlidXRlcyA9IFsndmFsJywgJ2NzcycsICdodG1sJywgJ3RleHQnLCAnZGF0YScsICd3aWR0aCcsICdoZWlnaHQnLCAnb2Zmc2V0J10sXFxuXFxuICAgIGFkamFjZW5jeU9wZXJhdG9ycyA9IFsgJ2FmdGVyJywgJ3ByZXBlbmQnLCAnYmVmb3JlJywgJ2FwcGVuZCcgXSxcXG4gICAgdGFibGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd0YWJsZScpLFxcbiAgICB0YWJsZVJvdyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3RyJyksXFxuICAgIGNvbnRhaW5lcnMgPSB7XFxuICAgICAgJ3RyJzogZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndGJvZHknKSxcXG4gICAgICAndGJvZHknOiB0YWJsZSwgJ3RoZWFkJzogdGFibGUsICd0Zm9vdCc6IHRhYmxlLFxcbiAgICAgICd0ZCc6IHRhYmxlUm93LCAndGgnOiB0YWJsZVJvdyxcXG4gICAgICAnKic6IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpXFxuICAgIH0sXFxuICAgIHJlYWR5UkUgPSAvY29tcGxldGV8bG9hZGVkfGludGVyYWN0aXZlLyxcXG4gICAgc2ltcGxlU2VsZWN0b3JSRSA9IC9eW1xcXFx3LV0qJC8sXFxuICAgIGNsYXNzMnR5cGUgPSB7fSxcXG4gICAgdG9TdHJpbmcgPSBjbGFzczJ0eXBlLnRvU3RyaW5nLFxcbiAgICB6ZXB0byA9IHt9LFxcbiAgICBjYW1lbGl6ZSwgdW5pcSxcXG4gICAgdGVtcFBhcmVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpLFxcbiAgICBwcm9wTWFwID0ge1xcbiAgICAgICd0YWJpbmRleCc6ICd0YWJJbmRleCcsXFxuICAgICAgJ3JlYWRvbmx5JzogJ3JlYWRPbmx5JyxcXG4gICAgICAnZm9yJzogJ2h0bWxGb3InLFxcbiAgICAgICdjbGFzcyc6ICdjbGFzc05hbWUnLFxcbiAgICAgICdtYXhsZW5ndGgnOiAnbWF4TGVuZ3RoJyxcXG4gICAgICAnY2VsbHNwYWNpbmcnOiAnY2VsbFNwYWNpbmcnLFxcbiAgICAgICdjZWxscGFkZGluZyc6ICdjZWxsUGFkZGluZycsXFxuICAgICAgJ3Jvd3NwYW4nOiAncm93U3BhbicsXFxuICAgICAgJ2NvbHNwYW4nOiAnY29sU3BhbicsXFxuICAgICAgJ3VzZW1hcCc6ICd1c2VNYXAnLFxcbiAgICAgICdmcmFtZWJvcmRlcic6ICdmcmFtZUJvcmRlcicsXFxuICAgICAgJ2NvbnRlbnRlZGl0YWJsZSc6ICdjb250ZW50RWRpdGFibGUnXFxuICAgIH0sXFxuICAgIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5IHx8XFxuICAgICAgZnVuY3Rpb24ob2JqZWN0KXsgcmV0dXJuIG9iamVjdCBpbnN0YW5jZW9mIEFycmF5IH1cXG5cXG4gIHplcHRvLm1hdGNoZXMgPSBmdW5jdGlvbihlbGVtZW50LCBzZWxlY3Rvcikge1xcbiAgICBpZiAoIXNlbGVjdG9yIHx8ICFlbGVtZW50IHx8IGVsZW1lbnQubm9kZVR5cGUgIT09IDEpIHJldHVybiBmYWxzZVxcbiAgICB2YXIgbWF0Y2hlc1NlbGVjdG9yID0gZWxlbWVudC5tYXRjaGVzIHx8IGVsZW1lbnQud2Via2l0TWF0Y2hlc1NlbGVjdG9yIHx8XFxuICAgICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50Lm1vek1hdGNoZXNTZWxlY3RvciB8fCBlbGVtZW50Lm9NYXRjaGVzU2VsZWN0b3IgfHxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnQubWF0Y2hlc1NlbGVjdG9yXFxuICAgIGlmIChtYXRjaGVzU2VsZWN0b3IpIHJldHVybiBtYXRjaGVzU2VsZWN0b3IuY2FsbChlbGVtZW50LCBzZWxlY3RvcilcXG4gICAgLy8gZmFsbCBiYWNrIHRvIHBlcmZvcm1pbmcgYSBzZWxlY3RvcjpcXG4gICAgdmFyIG1hdGNoLCBwYXJlbnQgPSBlbGVtZW50LnBhcmVudE5vZGUsIHRlbXAgPSAhcGFyZW50XFxuICAgIGlmICh0ZW1wKSAocGFyZW50ID0gdGVtcFBhcmVudCkuYXBwZW5kQ2hpbGQoZWxlbWVudClcXG4gICAgbWF0Y2ggPSB+emVwdG8ucXNhKHBhcmVudCwgc2VsZWN0b3IpLmluZGV4T2YoZWxlbWVudClcXG4gICAgdGVtcCAmJiB0ZW1wUGFyZW50LnJlbW92ZUNoaWxkKGVsZW1lbnQpXFxuICAgIHJldHVybiBtYXRjaFxcbiAgfVxcblxcbiAgZnVuY3Rpb24gdHlwZShvYmopIHtcXG4gICAgcmV0dXJuIG9iaiA9PSBudWxsID8gU3RyaW5nKG9iaikgOlxcbiAgICAgIGNsYXNzMnR5cGVbdG9TdHJpbmcuY2FsbChvYmopXSB8fCBcXFwib2JqZWN0XFxcIlxcbiAgfVxcblxcbiAgZnVuY3Rpb24gaXNGdW5jdGlvbih2YWx1ZSkgeyByZXR1cm4gdHlwZSh2YWx1ZSkgPT0gXFxcImZ1bmN0aW9uXFxcIiB9XFxuICBmdW5jdGlvbiBpc1dpbmRvdyhvYmopICAgICB7IHJldHVybiBvYmogIT0gbnVsbCAmJiBvYmogPT0gb2JqLndpbmRvdyB9XFxuICBmdW5jdGlvbiBpc0RvY3VtZW50KG9iaikgICB7IHJldHVybiBvYmogIT0gbnVsbCAmJiBvYmoubm9kZVR5cGUgPT0gb2JqLkRPQ1VNRU5UX05PREUgfVxcbiAgZnVuY3Rpb24gaXNPYmplY3Qob2JqKSAgICAgeyByZXR1cm4gdHlwZShvYmopID09IFxcXCJvYmplY3RcXFwiIH1cXG4gIGZ1bmN0aW9uIGlzUGxhaW5PYmplY3Qob2JqKSB7XFxuICAgIHJldHVybiBpc09iamVjdChvYmopICYmICFpc1dpbmRvdyhvYmopICYmIE9iamVjdC5nZXRQcm90b3R5cGVPZihvYmopID09IE9iamVjdC5wcm90b3R5cGVcXG4gIH1cXG5cXG4gIGZ1bmN0aW9uIGxpa2VBcnJheShvYmopIHtcXG4gICAgdmFyIGxlbmd0aCA9ICEhb2JqICYmICdsZW5ndGgnIGluIG9iaiAmJiBvYmoubGVuZ3RoLFxcbiAgICAgIHR5cGUgPSAkLnR5cGUob2JqKVxcblxcbiAgICByZXR1cm4gJ2Z1bmN0aW9uJyAhPSB0eXBlICYmICFpc1dpbmRvdyhvYmopICYmIChcXG4gICAgICAnYXJyYXknID09IHR5cGUgfHwgbGVuZ3RoID09PSAwIHx8XFxuICAgICAgICAodHlwZW9mIGxlbmd0aCA9PSAnbnVtYmVyJyAmJiBsZW5ndGggPiAwICYmIChsZW5ndGggLSAxKSBpbiBvYmopXFxuICAgIClcXG4gIH1cXG5cXG4gIGZ1bmN0aW9uIGNvbXBhY3QoYXJyYXkpIHsgcmV0dXJuIGZpbHRlci5jYWxsKGFycmF5LCBmdW5jdGlvbihpdGVtKXsgcmV0dXJuIGl0ZW0gIT0gbnVsbCB9KSB9XFxuICBmdW5jdGlvbiBmbGF0dGVuKGFycmF5KSB7IHJldHVybiBhcnJheS5sZW5ndGggPiAwID8gJC5mbi5jb25jYXQuYXBwbHkoW10sIGFycmF5KSA6IGFycmF5IH1cXG4gIGNhbWVsaXplID0gZnVuY3Rpb24oc3RyKXsgcmV0dXJuIHN0ci5yZXBsYWNlKC8tKyguKT8vZywgZnVuY3Rpb24obWF0Y2gsIGNocil7IHJldHVybiBjaHIgPyBjaHIudG9VcHBlckNhc2UoKSA6ICcnIH0pIH1cXG4gIGZ1bmN0aW9uIGRhc2hlcml6ZShzdHIpIHtcXG4gICAgcmV0dXJuIHN0ci5yZXBsYWNlKC86Oi9nLCAnLycpXFxuICAgICAgICAgICAucmVwbGFjZSgvKFtBLVpdKykoW0EtWl1bYS16XSkvZywgJyQxXyQyJylcXG4gICAgICAgICAgIC5yZXBsYWNlKC8oW2EtelxcXFxkXSkoW0EtWl0pL2csICckMV8kMicpXFxuICAgICAgICAgICAucmVwbGFjZSgvXy9nLCAnLScpXFxuICAgICAgICAgICAudG9Mb3dlckNhc2UoKVxcbiAgfVxcbiAgdW5pcSA9IGZ1bmN0aW9uKGFycmF5KXsgcmV0dXJuIGZpbHRlci5jYWxsKGFycmF5LCBmdW5jdGlvbihpdGVtLCBpZHgpeyByZXR1cm4gYXJyYXkuaW5kZXhPZihpdGVtKSA9PSBpZHggfSkgfVxcblxcbiAgZnVuY3Rpb24gY2xhc3NSRShuYW1lKSB7XFxuICAgIHJldHVybiBuYW1lIGluIGNsYXNzQ2FjaGUgP1xcbiAgICAgIGNsYXNzQ2FjaGVbbmFtZV0gOiAoY2xhc3NDYWNoZVtuYW1lXSA9IG5ldyBSZWdFeHAoJyhefFxcXFxcXFxccyknICsgbmFtZSArICcoXFxcXFxcXFxzfCQpJykpXFxuICB9XFxuXFxuICBmdW5jdGlvbiBtYXliZUFkZFB4KG5hbWUsIHZhbHVlKSB7XFxuICAgIHJldHVybiAodHlwZW9mIHZhbHVlID09IFxcXCJudW1iZXJcXFwiICYmICFjc3NOdW1iZXJbZGFzaGVyaXplKG5hbWUpXSkgPyB2YWx1ZSArIFxcXCJweFxcXCIgOiB2YWx1ZVxcbiAgfVxcblxcbiAgZnVuY3Rpb24gZGVmYXVsdERpc3BsYXkobm9kZU5hbWUpIHtcXG4gICAgdmFyIGVsZW1lbnQsIGRpc3BsYXlcXG4gICAgaWYgKCFlbGVtZW50RGlzcGxheVtub2RlTmFtZV0pIHtcXG4gICAgICBlbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChub2RlTmFtZSlcXG4gICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGVsZW1lbnQpXFxuICAgICAgZGlzcGxheSA9IGdldENvbXB1dGVkU3R5bGUoZWxlbWVudCwgJycpLmdldFByb3BlcnR5VmFsdWUoXFxcImRpc3BsYXlcXFwiKVxcbiAgICAgIGVsZW1lbnQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChlbGVtZW50KVxcbiAgICAgIGRpc3BsYXkgPT0gXFxcIm5vbmVcXFwiICYmIChkaXNwbGF5ID0gXFxcImJsb2NrXFxcIilcXG4gICAgICBlbGVtZW50RGlzcGxheVtub2RlTmFtZV0gPSBkaXNwbGF5XFxuICAgIH1cXG4gICAgcmV0dXJuIGVsZW1lbnREaXNwbGF5W25vZGVOYW1lXVxcbiAgfVxcblxcbiAgZnVuY3Rpb24gY2hpbGRyZW4oZWxlbWVudCkge1xcbiAgICByZXR1cm4gJ2NoaWxkcmVuJyBpbiBlbGVtZW50ID9cXG4gICAgICBzbGljZS5jYWxsKGVsZW1lbnQuY2hpbGRyZW4pIDpcXG4gICAgICAkLm1hcChlbGVtZW50LmNoaWxkTm9kZXMsIGZ1bmN0aW9uKG5vZGUpeyBpZiAobm9kZS5ub2RlVHlwZSA9PSAxKSByZXR1cm4gbm9kZSB9KVxcbiAgfVxcblxcbiAgZnVuY3Rpb24gWihkb20sIHNlbGVjdG9yKSB7XFxuICAgIHZhciBpLCBsZW4gPSBkb20gPyBkb20ubGVuZ3RoIDogMFxcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHRoaXNbaV0gPSBkb21baV1cXG4gICAgdGhpcy5sZW5ndGggPSBsZW5cXG4gICAgdGhpcy5zZWxlY3RvciA9IHNlbGVjdG9yIHx8ICcnXFxuICB9XFxuXFxuICAvLyBgJC56ZXB0by5mcmFnbWVudGAgdGFrZXMgYSBodG1sIHN0cmluZyBhbmQgYW4gb3B0aW9uYWwgdGFnIG5hbWVcXG4gIC8vIHRvIGdlbmVyYXRlIERPTSBub2RlcyBmcm9tIHRoZSBnaXZlbiBodG1sIHN0cmluZy5cXG4gIC8vIFRoZSBnZW5lcmF0ZWQgRE9NIG5vZGVzIGFyZSByZXR1cm5lZCBhcyBhbiBhcnJheS5cXG4gIC8vIFRoaXMgZnVuY3Rpb24gY2FuIGJlIG92ZXJyaWRkZW4gaW4gcGx1Z2lucyBmb3IgZXhhbXBsZSB0byBtYWtlXFxuICAvLyBpdCBjb21wYXRpYmxlIHdpdGggYnJvd3NlcnMgdGhhdCBkb24ndCBzdXBwb3J0IHRoZSBET00gZnVsbHkuXFxuICB6ZXB0by5mcmFnbWVudCA9IGZ1bmN0aW9uKGh0bWwsIG5hbWUsIHByb3BlcnRpZXMpIHtcXG4gICAgdmFyIGRvbSwgbm9kZXMsIGNvbnRhaW5lclxcblxcbiAgICAvLyBBIHNwZWNpYWwgY2FzZSBvcHRpbWl6YXRpb24gZm9yIGEgc2luZ2xlIHRhZ1xcbiAgICBpZiAoc2luZ2xlVGFnUkUudGVzdChodG1sKSkgZG9tID0gJChkb2N1bWVudC5jcmVhdGVFbGVtZW50KFJlZ0V4cC4kMSkpXFxuXFxuICAgIGlmICghZG9tKSB7XFxuICAgICAgaWYgKGh0bWwucmVwbGFjZSkgaHRtbCA9IGh0bWwucmVwbGFjZSh0YWdFeHBhbmRlclJFLCBcXFwiPCQxPjwvJDI+XFxcIilcXG4gICAgICBpZiAobmFtZSA9PT0gdW5kZWZpbmVkKSBuYW1lID0gZnJhZ21lbnRSRS50ZXN0KGh0bWwpICYmIFJlZ0V4cC4kMVxcbiAgICAgIGlmICghKG5hbWUgaW4gY29udGFpbmVycykpIG5hbWUgPSAnKidcXG5cXG4gICAgICBjb250YWluZXIgPSBjb250YWluZXJzW25hbWVdXFxuICAgICAgY29udGFpbmVyLmlubmVySFRNTCA9ICcnICsgaHRtbFxcbiAgICAgIGRvbSA9ICQuZWFjaChzbGljZS5jYWxsKGNvbnRhaW5lci5jaGlsZE5vZGVzKSwgZnVuY3Rpb24oKXtcXG4gICAgICAgIGNvbnRhaW5lci5yZW1vdmVDaGlsZCh0aGlzKVxcbiAgICAgIH0pXFxuICAgIH1cXG5cXG4gICAgaWYgKGlzUGxhaW5PYmplY3QocHJvcGVydGllcykpIHtcXG4gICAgICBub2RlcyA9ICQoZG9tKVxcbiAgICAgICQuZWFjaChwcm9wZXJ0aWVzLCBmdW5jdGlvbihrZXksIHZhbHVlKSB7XFxuICAgICAgICBpZiAobWV0aG9kQXR0cmlidXRlcy5pbmRleE9mKGtleSkgPiAtMSkgbm9kZXNba2V5XSh2YWx1ZSlcXG4gICAgICAgIGVsc2Ugbm9kZXMuYXR0cihrZXksIHZhbHVlKVxcbiAgICAgIH0pXFxuICAgIH1cXG5cXG4gICAgcmV0dXJuIGRvbVxcbiAgfVxcblxcbiAgLy8gYCQuemVwdG8uWmAgc3dhcHMgb3V0IHRoZSBwcm90b3R5cGUgb2YgdGhlIGdpdmVuIGBkb21gIGFycmF5XFxuICAvLyBvZiBub2RlcyB3aXRoIGAkLmZuYCBhbmQgdGh1cyBzdXBwbHlpbmcgYWxsIHRoZSBaZXB0byBmdW5jdGlvbnNcXG4gIC8vIHRvIHRoZSBhcnJheS4gVGhpcyBtZXRob2QgY2FuIGJlIG92ZXJyaWRkZW4gaW4gcGx1Z2lucy5cXG4gIHplcHRvLlogPSBmdW5jdGlvbihkb20sIHNlbGVjdG9yKSB7XFxuICAgIHJldHVybiBuZXcgWihkb20sIHNlbGVjdG9yKVxcbiAgfVxcblxcbiAgLy8gYCQuemVwdG8uaXNaYCBzaG91bGQgcmV0dXJuIGB0cnVlYCBpZiB0aGUgZ2l2ZW4gb2JqZWN0IGlzIGEgWmVwdG9cXG4gIC8vIGNvbGxlY3Rpb24uIFRoaXMgbWV0aG9kIGNhbiBiZSBvdmVycmlkZGVuIGluIHBsdWdpbnMuXFxuICB6ZXB0by5pc1ogPSBmdW5jdGlvbihvYmplY3QpIHtcXG4gICAgcmV0dXJuIG9iamVjdCBpbnN0YW5jZW9mIHplcHRvLlpcXG4gIH1cXG5cXG4gIC8vIGAkLnplcHRvLmluaXRgIGlzIFplcHRvJ3MgY291bnRlcnBhcnQgdG8galF1ZXJ5J3MgYCQuZm4uaW5pdGAgYW5kXFxuICAvLyB0YWtlcyBhIENTUyBzZWxlY3RvciBhbmQgYW4gb3B0aW9uYWwgY29udGV4dCAoYW5kIGhhbmRsZXMgdmFyaW91c1xcbiAgLy8gc3BlY2lhbCBjYXNlcykuXFxuICAvLyBUaGlzIG1ldGhvZCBjYW4gYmUgb3ZlcnJpZGRlbiBpbiBwbHVnaW5zLlxcbiAgemVwdG8uaW5pdCA9IGZ1bmN0aW9uKHNlbGVjdG9yLCBjb250ZXh0KSB7XFxuICAgIHZhciBkb21cXG4gICAgLy8gSWYgbm90aGluZyBnaXZlbiwgcmV0dXJuIGFuIGVtcHR5IFplcHRvIGNvbGxlY3Rpb25cXG4gICAgaWYgKCFzZWxlY3RvcikgcmV0dXJuIHplcHRvLlooKVxcbiAgICAvLyBPcHRpbWl6ZSBmb3Igc3RyaW5nIHNlbGVjdG9yc1xcbiAgICBlbHNlIGlmICh0eXBlb2Ygc2VsZWN0b3IgPT0gJ3N0cmluZycpIHtcXG4gICAgICBzZWxlY3RvciA9IHNlbGVjdG9yLnRyaW0oKVxcbiAgICAgIC8vIElmIGl0J3MgYSBodG1sIGZyYWdtZW50LCBjcmVhdGUgbm9kZXMgZnJvbSBpdFxcbiAgICAgIC8vIE5vdGU6IEluIGJvdGggQ2hyb21lIDIxIGFuZCBGaXJlZm94IDE1LCBET00gZXJyb3IgMTJcXG4gICAgICAvLyBpcyB0aHJvd24gaWYgdGhlIGZyYWdtZW50IGRvZXNuJ3QgYmVnaW4gd2l0aCA8XFxuICAgICAgaWYgKHNlbGVjdG9yWzBdID09ICc8JyAmJiBmcmFnbWVudFJFLnRlc3Qoc2VsZWN0b3IpKVxcbiAgICAgICAgZG9tID0gemVwdG8uZnJhZ21lbnQoc2VsZWN0b3IsIFJlZ0V4cC4kMSwgY29udGV4dCksIHNlbGVjdG9yID0gbnVsbFxcbiAgICAgIC8vIElmIHRoZXJlJ3MgYSBjb250ZXh0LCBjcmVhdGUgYSBjb2xsZWN0aW9uIG9uIHRoYXQgY29udGV4dCBmaXJzdCwgYW5kIHNlbGVjdFxcbiAgICAgIC8vIG5vZGVzIGZyb20gdGhlcmVcXG4gICAgICBlbHNlIGlmIChjb250ZXh0ICE9PSB1bmRlZmluZWQpIHJldHVybiAkKGNvbnRleHQpLmZpbmQoc2VsZWN0b3IpXFxuICAgICAgLy8gSWYgaXQncyBhIENTUyBzZWxlY3RvciwgdXNlIGl0IHRvIHNlbGVjdCBub2Rlcy5cXG4gICAgICBlbHNlIGRvbSA9IHplcHRvLnFzYShkb2N1bWVudCwgc2VsZWN0b3IpXFxuICAgIH1cXG4gICAgLy8gSWYgYSBmdW5jdGlvbiBpcyBnaXZlbiwgY2FsbCBpdCB3aGVuIHRoZSBET00gaXMgcmVhZHlcXG4gICAgZWxzZSBpZiAoaXNGdW5jdGlvbihzZWxlY3RvcikpIHJldHVybiAkKGRvY3VtZW50KS5yZWFkeShzZWxlY3RvcilcXG4gICAgLy8gSWYgYSBaZXB0byBjb2xsZWN0aW9uIGlzIGdpdmVuLCBqdXN0IHJldHVybiBpdFxcbiAgICBlbHNlIGlmICh6ZXB0by5pc1ooc2VsZWN0b3IpKSByZXR1cm4gc2VsZWN0b3JcXG4gICAgZWxzZSB7XFxuICAgICAgLy8gbm9ybWFsaXplIGFycmF5IGlmIGFuIGFycmF5IG9mIG5vZGVzIGlzIGdpdmVuXFxuICAgICAgaWYgKGlzQXJyYXkoc2VsZWN0b3IpKSBkb20gPSBjb21wYWN0KHNlbGVjdG9yKVxcbiAgICAgIC8vIFdyYXAgRE9NIG5vZGVzLlxcbiAgICAgIGVsc2UgaWYgKGlzT2JqZWN0KHNlbGVjdG9yKSlcXG4gICAgICAgIGRvbSA9IFtzZWxlY3Rvcl0sIHNlbGVjdG9yID0gbnVsbFxcbiAgICAgIC8vIElmIGl0J3MgYSBodG1sIGZyYWdtZW50LCBjcmVhdGUgbm9kZXMgZnJvbSBpdFxcbiAgICAgIGVsc2UgaWYgKGZyYWdtZW50UkUudGVzdChzZWxlY3RvcikpXFxuICAgICAgICBkb20gPSB6ZXB0by5mcmFnbWVudChzZWxlY3Rvci50cmltKCksIFJlZ0V4cC4kMSwgY29udGV4dCksIHNlbGVjdG9yID0gbnVsbFxcbiAgICAgIC8vIElmIHRoZXJlJ3MgYSBjb250ZXh0LCBjcmVhdGUgYSBjb2xsZWN0aW9uIG9uIHRoYXQgY29udGV4dCBmaXJzdCwgYW5kIHNlbGVjdFxcbiAgICAgIC8vIG5vZGVzIGZyb20gdGhlcmVcXG4gICAgICBlbHNlIGlmIChjb250ZXh0ICE9PSB1bmRlZmluZWQpIHJldHVybiAkKGNvbnRleHQpLmZpbmQoc2VsZWN0b3IpXFxuICAgICAgLy8gQW5kIGxhc3QgYnV0IG5vIGxlYXN0LCBpZiBpdCdzIGEgQ1NTIHNlbGVjdG9yLCB1c2UgaXQgdG8gc2VsZWN0IG5vZGVzLlxcbiAgICAgIGVsc2UgZG9tID0gemVwdG8ucXNhKGRvY3VtZW50LCBzZWxlY3RvcilcXG4gICAgfVxcbiAgICAvLyBjcmVhdGUgYSBuZXcgWmVwdG8gY29sbGVjdGlvbiBmcm9tIHRoZSBub2RlcyBmb3VuZFxcbiAgICByZXR1cm4gemVwdG8uWihkb20sIHNlbGVjdG9yKVxcbiAgfVxcblxcbiAgLy8gYCRgIHdpbGwgYmUgdGhlIGJhc2UgYFplcHRvYCBvYmplY3QuIFdoZW4gY2FsbGluZyB0aGlzXFxuICAvLyBmdW5jdGlvbiBqdXN0IGNhbGwgYCQuemVwdG8uaW5pdCwgd2hpY2ggbWFrZXMgdGhlIGltcGxlbWVudGF0aW9uXFxuICAvLyBkZXRhaWxzIG9mIHNlbGVjdGluZyBub2RlcyBhbmQgY3JlYXRpbmcgWmVwdG8gY29sbGVjdGlvbnNcXG4gIC8vIHBhdGNoYWJsZSBpbiBwbHVnaW5zLlxcbiAgJCA9IGZ1bmN0aW9uKHNlbGVjdG9yLCBjb250ZXh0KXtcXG4gICAgcmV0dXJuIHplcHRvLmluaXQoc2VsZWN0b3IsIGNvbnRleHQpXFxuICB9XFxuXFxuICBmdW5jdGlvbiBleHRlbmQodGFyZ2V0LCBzb3VyY2UsIGRlZXApIHtcXG4gICAgZm9yIChrZXkgaW4gc291cmNlKVxcbiAgICAgIGlmIChkZWVwICYmIChpc1BsYWluT2JqZWN0KHNvdXJjZVtrZXldKSB8fCBpc0FycmF5KHNvdXJjZVtrZXldKSkpIHtcXG4gICAgICAgIGlmIChpc1BsYWluT2JqZWN0KHNvdXJjZVtrZXldKSAmJiAhaXNQbGFpbk9iamVjdCh0YXJnZXRba2V5XSkpXFxuICAgICAgICAgIHRhcmdldFtrZXldID0ge31cXG4gICAgICAgIGlmIChpc0FycmF5KHNvdXJjZVtrZXldKSAmJiAhaXNBcnJheSh0YXJnZXRba2V5XSkpXFxuICAgICAgICAgIHRhcmdldFtrZXldID0gW11cXG4gICAgICAgIGV4dGVuZCh0YXJnZXRba2V5XSwgc291cmNlW2tleV0sIGRlZXApXFxuICAgICAgfVxcbiAgICAgIGVsc2UgaWYgKHNvdXJjZVtrZXldICE9PSB1bmRlZmluZWQpIHRhcmdldFtrZXldID0gc291cmNlW2tleV1cXG4gIH1cXG5cXG4gIC8vIENvcHkgYWxsIGJ1dCB1bmRlZmluZWQgcHJvcGVydGllcyBmcm9tIG9uZSBvciBtb3JlXFxuICAvLyBvYmplY3RzIHRvIHRoZSBgdGFyZ2V0YCBvYmplY3QuXFxuICAkLmV4dGVuZCA9IGZ1bmN0aW9uKHRhcmdldCl7XFxuICAgIHZhciBkZWVwLCBhcmdzID0gc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpXFxuICAgIGlmICh0eXBlb2YgdGFyZ2V0ID09ICdib29sZWFuJykge1xcbiAgICAgIGRlZXAgPSB0YXJnZXRcXG4gICAgICB0YXJnZXQgPSBhcmdzLnNoaWZ0KClcXG4gICAgfVxcbiAgICBhcmdzLmZvckVhY2goZnVuY3Rpb24oYXJnKXsgZXh0ZW5kKHRhcmdldCwgYXJnLCBkZWVwKSB9KVxcbiAgICByZXR1cm4gdGFyZ2V0XFxuICB9XFxuXFxuICAvLyBgJC56ZXB0by5xc2FgIGlzIFplcHRvJ3MgQ1NTIHNlbGVjdG9yIGltcGxlbWVudGF0aW9uIHdoaWNoXFxuICAvLyB1c2VzIGBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsYCBhbmQgb3B0aW1pemVzIGZvciBzb21lIHNwZWNpYWwgY2FzZXMsIGxpa2UgYCNpZGAuXFxuICAvLyBUaGlzIG1ldGhvZCBjYW4gYmUgb3ZlcnJpZGRlbiBpbiBwbHVnaW5zLlxcbiAgemVwdG8ucXNhID0gZnVuY3Rpb24oZWxlbWVudCwgc2VsZWN0b3Ipe1xcbiAgICB2YXIgZm91bmQsXFxuICAgICAgICBtYXliZUlEID0gc2VsZWN0b3JbMF0gPT0gJyMnLFxcbiAgICAgICAgbWF5YmVDbGFzcyA9ICFtYXliZUlEICYmIHNlbGVjdG9yWzBdID09ICcuJyxcXG4gICAgICAgIG5hbWVPbmx5ID0gbWF5YmVJRCB8fCBtYXliZUNsYXNzID8gc2VsZWN0b3Iuc2xpY2UoMSkgOiBzZWxlY3RvciwgLy8gRW5zdXJlIHRoYXQgYSAxIGNoYXIgdGFnIG5hbWUgc3RpbGwgZ2V0cyBjaGVja2VkXFxuICAgICAgICBpc1NpbXBsZSA9IHNpbXBsZVNlbGVjdG9yUkUudGVzdChuYW1lT25seSlcXG4gICAgcmV0dXJuIChlbGVtZW50LmdldEVsZW1lbnRCeUlkICYmIGlzU2ltcGxlICYmIG1heWJlSUQpID8gLy8gU2FmYXJpIERvY3VtZW50RnJhZ21lbnQgZG9lc24ndCBoYXZlIGdldEVsZW1lbnRCeUlkXFxuICAgICAgKCAoZm91bmQgPSBlbGVtZW50LmdldEVsZW1lbnRCeUlkKG5hbWVPbmx5KSkgPyBbZm91bmRdIDogW10gKSA6XFxuICAgICAgKGVsZW1lbnQubm9kZVR5cGUgIT09IDEgJiYgZWxlbWVudC5ub2RlVHlwZSAhPT0gOSAmJiBlbGVtZW50Lm5vZGVUeXBlICE9PSAxMSkgPyBbXSA6XFxuICAgICAgc2xpY2UuY2FsbChcXG4gICAgICAgIGlzU2ltcGxlICYmICFtYXliZUlEICYmIGVsZW1lbnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSA/IC8vIERvY3VtZW50RnJhZ21lbnQgZG9lc24ndCBoYXZlIGdldEVsZW1lbnRzQnlDbGFzc05hbWUvVGFnTmFtZVxcbiAgICAgICAgICBtYXliZUNsYXNzID8gZWxlbWVudC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKG5hbWVPbmx5KSA6IC8vIElmIGl0J3Mgc2ltcGxlLCBpdCBjb3VsZCBiZSBhIGNsYXNzXFxuICAgICAgICAgIGVsZW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoc2VsZWN0b3IpIDogLy8gT3IgYSB0YWdcXG4gICAgICAgICAgZWxlbWVudC5xdWVyeVNlbGVjdG9yQWxsKHNlbGVjdG9yKSAvLyBPciBpdCdzIG5vdCBzaW1wbGUsIGFuZCB3ZSBuZWVkIHRvIHF1ZXJ5IGFsbFxcbiAgICAgIClcXG4gIH1cXG5cXG4gIGZ1bmN0aW9uIGZpbHRlcmVkKG5vZGVzLCBzZWxlY3Rvcikge1xcbiAgICByZXR1cm4gc2VsZWN0b3IgPT0gbnVsbCA/ICQobm9kZXMpIDogJChub2RlcykuZmlsdGVyKHNlbGVjdG9yKVxcbiAgfVxcblxcbiAgJC5jb250YWlucyA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jb250YWlucyA/XFxuICAgIGZ1bmN0aW9uKHBhcmVudCwgbm9kZSkge1xcbiAgICAgIHJldHVybiBwYXJlbnQgIT09IG5vZGUgJiYgcGFyZW50LmNvbnRhaW5zKG5vZGUpXFxuICAgIH0gOlxcbiAgICBmdW5jdGlvbihwYXJlbnQsIG5vZGUpIHtcXG4gICAgICB3aGlsZSAobm9kZSAmJiAobm9kZSA9IG5vZGUucGFyZW50Tm9kZSkpXFxuICAgICAgICBpZiAobm9kZSA9PT0gcGFyZW50KSByZXR1cm4gdHJ1ZVxcbiAgICAgIHJldHVybiBmYWxzZVxcbiAgICB9XFxuXFxuICBmdW5jdGlvbiBmdW5jQXJnKGNvbnRleHQsIGFyZywgaWR4LCBwYXlsb2FkKSB7XFxuICAgIHJldHVybiBpc0Z1bmN0aW9uKGFyZykgPyBhcmcuY2FsbChjb250ZXh0LCBpZHgsIHBheWxvYWQpIDogYXJnXFxuICB9XFxuXFxuICBmdW5jdGlvbiBzZXRBdHRyaWJ1dGUobm9kZSwgbmFtZSwgdmFsdWUpIHtcXG4gICAgdmFsdWUgPT0gbnVsbCA/IG5vZGUucmVtb3ZlQXR0cmlidXRlKG5hbWUpIDogbm9kZS5zZXRBdHRyaWJ1dGUobmFtZSwgdmFsdWUpXFxuICB9XFxuXFxuICAvLyBhY2Nlc3MgY2xhc3NOYW1lIHByb3BlcnR5IHdoaWxlIHJlc3BlY3RpbmcgU1ZHQW5pbWF0ZWRTdHJpbmdcXG4gIGZ1bmN0aW9uIGNsYXNzTmFtZShub2RlLCB2YWx1ZSl7XFxuICAgIHZhciBrbGFzcyA9IG5vZGUuY2xhc3NOYW1lIHx8ICcnLFxcbiAgICAgICAgc3ZnICAgPSBrbGFzcyAmJiBrbGFzcy5iYXNlVmFsICE9PSB1bmRlZmluZWRcXG5cXG4gICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHJldHVybiBzdmcgPyBrbGFzcy5iYXNlVmFsIDoga2xhc3NcXG4gICAgc3ZnID8gKGtsYXNzLmJhc2VWYWwgPSB2YWx1ZSkgOiAobm9kZS5jbGFzc05hbWUgPSB2YWx1ZSlcXG4gIH1cXG5cXG4gIC8vIFxcXCJ0cnVlXFxcIiAgPT4gdHJ1ZVxcbiAgLy8gXFxcImZhbHNlXFxcIiA9PiBmYWxzZVxcbiAgLy8gXFxcIm51bGxcXFwiICA9PiBudWxsXFxuICAvLyBcXFwiNDJcXFwiICAgID0+IDQyXFxuICAvLyBcXFwiNDIuNVxcXCIgID0+IDQyLjVcXG4gIC8vIFxcXCIwOFxcXCIgICAgPT4gXFxcIjA4XFxcIlxcbiAgLy8gSlNPTiAgICA9PiBwYXJzZSBpZiB2YWxpZFxcbiAgLy8gU3RyaW5nICA9PiBzZWxmXFxuICBmdW5jdGlvbiBkZXNlcmlhbGl6ZVZhbHVlKHZhbHVlKSB7XFxuICAgIHRyeSB7XFxuICAgICAgcmV0dXJuIHZhbHVlID9cXG4gICAgICAgIHZhbHVlID09IFxcXCJ0cnVlXFxcIiB8fFxcbiAgICAgICAgKCB2YWx1ZSA9PSBcXFwiZmFsc2VcXFwiID8gZmFsc2UgOlxcbiAgICAgICAgICB2YWx1ZSA9PSBcXFwibnVsbFxcXCIgPyBudWxsIDpcXG4gICAgICAgICAgK3ZhbHVlICsgXFxcIlxcXCIgPT0gdmFsdWUgPyArdmFsdWUgOlxcbiAgICAgICAgICAvXltcXFxcW1xcXFx7XS8udGVzdCh2YWx1ZSkgPyAkLnBhcnNlSlNPTih2YWx1ZSkgOlxcbiAgICAgICAgICB2YWx1ZSApXFxuICAgICAgICA6IHZhbHVlXFxuICAgIH0gY2F0Y2goZSkge1xcbiAgICAgIHJldHVybiB2YWx1ZVxcbiAgICB9XFxuICB9XFxuXFxuICAkLnR5cGUgPSB0eXBlXFxuICAkLmlzRnVuY3Rpb24gPSBpc0Z1bmN0aW9uXFxuICAkLmlzV2luZG93ID0gaXNXaW5kb3dcXG4gICQuaXNBcnJheSA9IGlzQXJyYXlcXG4gICQuaXNQbGFpbk9iamVjdCA9IGlzUGxhaW5PYmplY3RcXG5cXG4gICQuaXNFbXB0eU9iamVjdCA9IGZ1bmN0aW9uKG9iaikge1xcbiAgICB2YXIgbmFtZVxcbiAgICBmb3IgKG5hbWUgaW4gb2JqKSByZXR1cm4gZmFsc2VcXG4gICAgcmV0dXJuIHRydWVcXG4gIH1cXG5cXG4gICQuaXNOdW1lcmljID0gZnVuY3Rpb24odmFsKSB7XFxuICAgIHZhciBudW0gPSBOdW1iZXIodmFsKSwgdHlwZSA9IHR5cGVvZiB2YWxcXG4gICAgcmV0dXJuIHZhbCAhPSBudWxsICYmIHR5cGUgIT0gJ2Jvb2xlYW4nICYmXFxuICAgICAgKHR5cGUgIT0gJ3N0cmluZycgfHwgdmFsLmxlbmd0aCkgJiZcXG4gICAgICAhaXNOYU4obnVtKSAmJiBpc0Zpbml0ZShudW0pIHx8IGZhbHNlXFxuICB9XFxuXFxuICAkLmluQXJyYXkgPSBmdW5jdGlvbihlbGVtLCBhcnJheSwgaSl7XFxuICAgIHJldHVybiBlbXB0eUFycmF5LmluZGV4T2YuY2FsbChhcnJheSwgZWxlbSwgaSlcXG4gIH1cXG5cXG4gICQuY2FtZWxDYXNlID0gY2FtZWxpemVcXG4gICQudHJpbSA9IGZ1bmN0aW9uKHN0cikge1xcbiAgICByZXR1cm4gc3RyID09IG51bGwgPyBcXFwiXFxcIiA6IFN0cmluZy5wcm90b3R5cGUudHJpbS5jYWxsKHN0cilcXG4gIH1cXG5cXG4gIC8vIHBsdWdpbiBjb21wYXRpYmlsaXR5XFxuICAkLnV1aWQgPSAwXFxuICAkLnN1cHBvcnQgPSB7IH1cXG4gICQuZXhwciA9IHsgfVxcbiAgJC5ub29wID0gZnVuY3Rpb24oKSB7fVxcblxcbiAgJC5tYXAgPSBmdW5jdGlvbihlbGVtZW50cywgY2FsbGJhY2spe1xcbiAgICB2YXIgdmFsdWUsIHZhbHVlcyA9IFtdLCBpLCBrZXlcXG4gICAgaWYgKGxpa2VBcnJheShlbGVtZW50cykpXFxuICAgICAgZm9yIChpID0gMDsgaSA8IGVsZW1lbnRzLmxlbmd0aDsgaSsrKSB7XFxuICAgICAgICB2YWx1ZSA9IGNhbGxiYWNrKGVsZW1lbnRzW2ldLCBpKVxcbiAgICAgICAgaWYgKHZhbHVlICE9IG51bGwpIHZhbHVlcy5wdXNoKHZhbHVlKVxcbiAgICAgIH1cXG4gICAgZWxzZVxcbiAgICAgIGZvciAoa2V5IGluIGVsZW1lbnRzKSB7XFxuICAgICAgICB2YWx1ZSA9IGNhbGxiYWNrKGVsZW1lbnRzW2tleV0sIGtleSlcXG4gICAgICAgIGlmICh2YWx1ZSAhPSBudWxsKSB2YWx1ZXMucHVzaCh2YWx1ZSlcXG4gICAgICB9XFxuICAgIHJldHVybiBmbGF0dGVuKHZhbHVlcylcXG4gIH1cXG5cXG4gICQuZWFjaCA9IGZ1bmN0aW9uKGVsZW1lbnRzLCBjYWxsYmFjayl7XFxuICAgIHZhciBpLCBrZXlcXG4gICAgaWYgKGxpa2VBcnJheShlbGVtZW50cykpIHtcXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgZWxlbWVudHMubGVuZ3RoOyBpKyspXFxuICAgICAgICBpZiAoY2FsbGJhY2suY2FsbChlbGVtZW50c1tpXSwgaSwgZWxlbWVudHNbaV0pID09PSBmYWxzZSkgcmV0dXJuIGVsZW1lbnRzXFxuICAgIH0gZWxzZSB7XFxuICAgICAgZm9yIChrZXkgaW4gZWxlbWVudHMpXFxuICAgICAgICBpZiAoY2FsbGJhY2suY2FsbChlbGVtZW50c1trZXldLCBrZXksIGVsZW1lbnRzW2tleV0pID09PSBmYWxzZSkgcmV0dXJuIGVsZW1lbnRzXFxuICAgIH1cXG5cXG4gICAgcmV0dXJuIGVsZW1lbnRzXFxuICB9XFxuXFxuICAkLmdyZXAgPSBmdW5jdGlvbihlbGVtZW50cywgY2FsbGJhY2spe1xcbiAgICByZXR1cm4gZmlsdGVyLmNhbGwoZWxlbWVudHMsIGNhbGxiYWNrKVxcbiAgfVxcblxcbiAgaWYgKHdpbmRvdy5KU09OKSAkLnBhcnNlSlNPTiA9IEpTT04ucGFyc2VcXG5cXG4gIC8vIFBvcHVsYXRlIHRoZSBjbGFzczJ0eXBlIG1hcFxcbiAgJC5lYWNoKFxcXCJCb29sZWFuIE51bWJlciBTdHJpbmcgRnVuY3Rpb24gQXJyYXkgRGF0ZSBSZWdFeHAgT2JqZWN0IEVycm9yXFxcIi5zcGxpdChcXFwiIFxcXCIpLCBmdW5jdGlvbihpLCBuYW1lKSB7XFxuICAgIGNsYXNzMnR5cGVbIFxcXCJbb2JqZWN0IFxcXCIgKyBuYW1lICsgXFxcIl1cXFwiIF0gPSBuYW1lLnRvTG93ZXJDYXNlKClcXG4gIH0pXFxuXFxuICAvLyBEZWZpbmUgbWV0aG9kcyB0aGF0IHdpbGwgYmUgYXZhaWxhYmxlIG9uIGFsbFxcbiAgLy8gWmVwdG8gY29sbGVjdGlvbnNcXG4gICQuZm4gPSB7XFxuICAgIGNvbnN0cnVjdG9yOiB6ZXB0by5aLFxcbiAgICBsZW5ndGg6IDAsXFxuXFxuICAgIC8vIEJlY2F1c2UgYSBjb2xsZWN0aW9uIGFjdHMgbGlrZSBhbiBhcnJheVxcbiAgICAvLyBjb3B5IG92ZXIgdGhlc2UgdXNlZnVsIGFycmF5IGZ1bmN0aW9ucy5cXG4gICAgZm9yRWFjaDogZW1wdHlBcnJheS5mb3JFYWNoLFxcbiAgICByZWR1Y2U6IGVtcHR5QXJyYXkucmVkdWNlLFxcbiAgICBwdXNoOiBlbXB0eUFycmF5LnB1c2gsXFxuICAgIHNvcnQ6IGVtcHR5QXJyYXkuc29ydCxcXG4gICAgc3BsaWNlOiBlbXB0eUFycmF5LnNwbGljZSxcXG4gICAgaW5kZXhPZjogZW1wdHlBcnJheS5pbmRleE9mLFxcbiAgICBjb25jYXQ6IGZ1bmN0aW9uKCl7XFxuICAgICAgdmFyIGksIHZhbHVlLCBhcmdzID0gW11cXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XFxuICAgICAgICB2YWx1ZSA9IGFyZ3VtZW50c1tpXVxcbiAgICAgICAgYXJnc1tpXSA9IHplcHRvLmlzWih2YWx1ZSkgPyB2YWx1ZS50b0FycmF5KCkgOiB2YWx1ZVxcbiAgICAgIH1cXG4gICAgICByZXR1cm4gY29uY2F0LmFwcGx5KHplcHRvLmlzWih0aGlzKSA/IHRoaXMudG9BcnJheSgpIDogdGhpcywgYXJncylcXG4gICAgfSxcXG5cXG4gICAgLy8gYG1hcGAgYW5kIGBzbGljZWAgaW4gdGhlIGpRdWVyeSBBUEkgd29yayBkaWZmZXJlbnRseVxcbiAgICAvLyBmcm9tIHRoZWlyIGFycmF5IGNvdW50ZXJwYXJ0c1xcbiAgICBtYXA6IGZ1bmN0aW9uKGZuKXtcXG4gICAgICByZXR1cm4gJCgkLm1hcCh0aGlzLCBmdW5jdGlvbihlbCwgaSl7IHJldHVybiBmbi5jYWxsKGVsLCBpLCBlbCkgfSkpXFxuICAgIH0sXFxuICAgIHNsaWNlOiBmdW5jdGlvbigpe1xcbiAgICAgIHJldHVybiAkKHNsaWNlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpXFxuICAgIH0sXFxuXFxuICAgIHJlYWR5OiBmdW5jdGlvbihjYWxsYmFjayl7XFxuICAgICAgLy8gbmVlZCB0byBjaGVjayBpZiBkb2N1bWVudC5ib2R5IGV4aXN0cyBmb3IgSUUgYXMgdGhhdCBicm93c2VyIHJlcG9ydHNcXG4gICAgICAvLyBkb2N1bWVudCByZWFkeSB3aGVuIGl0IGhhc24ndCB5ZXQgY3JlYXRlZCB0aGUgYm9keSBlbGVtZW50XFxuICAgICAgaWYgKHJlYWR5UkUudGVzdChkb2N1bWVudC5yZWFkeVN0YXRlKSAmJiBkb2N1bWVudC5ib2R5KSBjYWxsYmFjaygkKVxcbiAgICAgIGVsc2UgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignRE9NQ29udGVudExvYWRlZCcsIGZ1bmN0aW9uKCl7IGNhbGxiYWNrKCQpIH0sIGZhbHNlKVxcbiAgICAgIHJldHVybiB0aGlzXFxuICAgIH0sXFxuICAgIGdldDogZnVuY3Rpb24oaWR4KXtcXG4gICAgICByZXR1cm4gaWR4ID09PSB1bmRlZmluZWQgPyBzbGljZS5jYWxsKHRoaXMpIDogdGhpc1tpZHggPj0gMCA/IGlkeCA6IGlkeCArIHRoaXMubGVuZ3RoXVxcbiAgICB9LFxcbiAgICB0b0FycmF5OiBmdW5jdGlvbigpeyByZXR1cm4gdGhpcy5nZXQoKSB9LFxcbiAgICBzaXplOiBmdW5jdGlvbigpe1xcbiAgICAgIHJldHVybiB0aGlzLmxlbmd0aFxcbiAgICB9LFxcbiAgICByZW1vdmU6IGZ1bmN0aW9uKCl7XFxuICAgICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpe1xcbiAgICAgICAgaWYgKHRoaXMucGFyZW50Tm9kZSAhPSBudWxsKVxcbiAgICAgICAgICB0aGlzLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcylcXG4gICAgICB9KVxcbiAgICB9LFxcbiAgICBlYWNoOiBmdW5jdGlvbihjYWxsYmFjayl7XFxuICAgICAgZW1wdHlBcnJheS5ldmVyeS5jYWxsKHRoaXMsIGZ1bmN0aW9uKGVsLCBpZHgpe1xcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrLmNhbGwoZWwsIGlkeCwgZWwpICE9PSBmYWxzZVxcbiAgICAgIH0pXFxuICAgICAgcmV0dXJuIHRoaXNcXG4gICAgfSxcXG4gICAgZmlsdGVyOiBmdW5jdGlvbihzZWxlY3Rvcil7XFxuICAgICAgaWYgKGlzRnVuY3Rpb24oc2VsZWN0b3IpKSByZXR1cm4gdGhpcy5ub3QodGhpcy5ub3Qoc2VsZWN0b3IpKVxcbiAgICAgIHJldHVybiAkKGZpbHRlci5jYWxsKHRoaXMsIGZ1bmN0aW9uKGVsZW1lbnQpe1xcbiAgICAgICAgcmV0dXJuIHplcHRvLm1hdGNoZXMoZWxlbWVudCwgc2VsZWN0b3IpXFxuICAgICAgfSkpXFxuICAgIH0sXFxuICAgIGFkZDogZnVuY3Rpb24oc2VsZWN0b3IsY29udGV4dCl7XFxuICAgICAgcmV0dXJuICQodW5pcSh0aGlzLmNvbmNhdCgkKHNlbGVjdG9yLGNvbnRleHQpKSkpXFxuICAgIH0sXFxuICAgIGlzOiBmdW5jdGlvbihzZWxlY3Rvcil7XFxuICAgICAgcmV0dXJuIHRoaXMubGVuZ3RoID4gMCAmJiB6ZXB0by5tYXRjaGVzKHRoaXNbMF0sIHNlbGVjdG9yKVxcbiAgICB9LFxcbiAgICBub3Q6IGZ1bmN0aW9uKHNlbGVjdG9yKXtcXG4gICAgICB2YXIgbm9kZXM9W11cXG4gICAgICBpZiAoaXNGdW5jdGlvbihzZWxlY3RvcikgJiYgc2VsZWN0b3IuY2FsbCAhPT0gdW5kZWZpbmVkKVxcbiAgICAgICAgdGhpcy5lYWNoKGZ1bmN0aW9uKGlkeCl7XFxuICAgICAgICAgIGlmICghc2VsZWN0b3IuY2FsbCh0aGlzLGlkeCkpIG5vZGVzLnB1c2godGhpcylcXG4gICAgICAgIH0pXFxuICAgICAgZWxzZSB7XFxuICAgICAgICB2YXIgZXhjbHVkZXMgPSB0eXBlb2Ygc2VsZWN0b3IgPT0gJ3N0cmluZycgPyB0aGlzLmZpbHRlcihzZWxlY3RvcikgOlxcbiAgICAgICAgICAobGlrZUFycmF5KHNlbGVjdG9yKSAmJiBpc0Z1bmN0aW9uKHNlbGVjdG9yLml0ZW0pKSA/IHNsaWNlLmNhbGwoc2VsZWN0b3IpIDogJChzZWxlY3RvcilcXG4gICAgICAgIHRoaXMuZm9yRWFjaChmdW5jdGlvbihlbCl7XFxuICAgICAgICAgIGlmIChleGNsdWRlcy5pbmRleE9mKGVsKSA8IDApIG5vZGVzLnB1c2goZWwpXFxuICAgICAgICB9KVxcbiAgICAgIH1cXG4gICAgICByZXR1cm4gJChub2RlcylcXG4gICAgfSxcXG4gICAgaGFzOiBmdW5jdGlvbihzZWxlY3Rvcil7XFxuICAgICAgcmV0dXJuIHRoaXMuZmlsdGVyKGZ1bmN0aW9uKCl7XFxuICAgICAgICByZXR1cm4gaXNPYmplY3Qoc2VsZWN0b3IpID9cXG4gICAgICAgICAgJC5jb250YWlucyh0aGlzLCBzZWxlY3RvcikgOlxcbiAgICAgICAgICAkKHRoaXMpLmZpbmQoc2VsZWN0b3IpLnNpemUoKVxcbiAgICAgIH0pXFxuICAgIH0sXFxuICAgIGVxOiBmdW5jdGlvbihpZHgpe1xcbiAgICAgIHJldHVybiBpZHggPT09IC0xID8gdGhpcy5zbGljZShpZHgpIDogdGhpcy5zbGljZShpZHgsICsgaWR4ICsgMSlcXG4gICAgfSxcXG4gICAgZmlyc3Q6IGZ1bmN0aW9uKCl7XFxuICAgICAgdmFyIGVsID0gdGhpc1swXVxcbiAgICAgIHJldHVybiBlbCAmJiAhaXNPYmplY3QoZWwpID8gZWwgOiAkKGVsKVxcbiAgICB9LFxcbiAgICBsYXN0OiBmdW5jdGlvbigpe1xcbiAgICAgIHZhciBlbCA9IHRoaXNbdGhpcy5sZW5ndGggLSAxXVxcbiAgICAgIHJldHVybiBlbCAmJiAhaXNPYmplY3QoZWwpID8gZWwgOiAkKGVsKVxcbiAgICB9LFxcbiAgICBmaW5kOiBmdW5jdGlvbihzZWxlY3Rvcil7XFxuICAgICAgdmFyIHJlc3VsdCwgJHRoaXMgPSB0aGlzXFxuICAgICAgaWYgKCFzZWxlY3RvcikgcmVzdWx0ID0gJCgpXFxuICAgICAgZWxzZSBpZiAodHlwZW9mIHNlbGVjdG9yID09ICdvYmplY3QnKVxcbiAgICAgICAgcmVzdWx0ID0gJChzZWxlY3RvcikuZmlsdGVyKGZ1bmN0aW9uKCl7XFxuICAgICAgICAgIHZhciBub2RlID0gdGhpc1xcbiAgICAgICAgICByZXR1cm4gZW1wdHlBcnJheS5zb21lLmNhbGwoJHRoaXMsIGZ1bmN0aW9uKHBhcmVudCl7XFxuICAgICAgICAgICAgcmV0dXJuICQuY29udGFpbnMocGFyZW50LCBub2RlKVxcbiAgICAgICAgICB9KVxcbiAgICAgICAgfSlcXG4gICAgICBlbHNlIGlmICh0aGlzLmxlbmd0aCA9PSAxKSByZXN1bHQgPSAkKHplcHRvLnFzYSh0aGlzWzBdLCBzZWxlY3RvcikpXFxuICAgICAgZWxzZSByZXN1bHQgPSB0aGlzLm1hcChmdW5jdGlvbigpeyByZXR1cm4gemVwdG8ucXNhKHRoaXMsIHNlbGVjdG9yKSB9KVxcbiAgICAgIHJldHVybiByZXN1bHRcXG4gICAgfSxcXG4gICAgY2xvc2VzdDogZnVuY3Rpb24oc2VsZWN0b3IsIGNvbnRleHQpe1xcbiAgICAgIHZhciBub2RlcyA9IFtdLCBjb2xsZWN0aW9uID0gdHlwZW9mIHNlbGVjdG9yID09ICdvYmplY3QnICYmICQoc2VsZWN0b3IpXFxuICAgICAgdGhpcy5lYWNoKGZ1bmN0aW9uKF8sIG5vZGUpe1xcbiAgICAgICAgd2hpbGUgKG5vZGUgJiYgIShjb2xsZWN0aW9uID8gY29sbGVjdGlvbi5pbmRleE9mKG5vZGUpID49IDAgOiB6ZXB0by5tYXRjaGVzKG5vZGUsIHNlbGVjdG9yKSkpXFxuICAgICAgICAgIG5vZGUgPSBub2RlICE9PSBjb250ZXh0ICYmICFpc0RvY3VtZW50KG5vZGUpICYmIG5vZGUucGFyZW50Tm9kZVxcbiAgICAgICAgaWYgKG5vZGUgJiYgbm9kZXMuaW5kZXhPZihub2RlKSA8IDApIG5vZGVzLnB1c2gobm9kZSlcXG4gICAgICB9KVxcbiAgICAgIHJldHVybiAkKG5vZGVzKVxcbiAgICB9LFxcbiAgICBwYXJlbnRzOiBmdW5jdGlvbihzZWxlY3Rvcil7XFxuICAgICAgdmFyIGFuY2VzdG9ycyA9IFtdLCBub2RlcyA9IHRoaXNcXG4gICAgICB3aGlsZSAobm9kZXMubGVuZ3RoID4gMClcXG4gICAgICAgIG5vZGVzID0gJC5tYXAobm9kZXMsIGZ1bmN0aW9uKG5vZGUpe1xcbiAgICAgICAgICBpZiAoKG5vZGUgPSBub2RlLnBhcmVudE5vZGUpICYmICFpc0RvY3VtZW50KG5vZGUpICYmIGFuY2VzdG9ycy5pbmRleE9mKG5vZGUpIDwgMCkge1xcbiAgICAgICAgICAgIGFuY2VzdG9ycy5wdXNoKG5vZGUpXFxuICAgICAgICAgICAgcmV0dXJuIG5vZGVcXG4gICAgICAgICAgfVxcbiAgICAgICAgfSlcXG4gICAgICByZXR1cm4gZmlsdGVyZWQoYW5jZXN0b3JzLCBzZWxlY3RvcilcXG4gICAgfSxcXG4gICAgcGFyZW50OiBmdW5jdGlvbihzZWxlY3Rvcil7XFxuICAgICAgcmV0dXJuIGZpbHRlcmVkKHVuaXEodGhpcy5wbHVjaygncGFyZW50Tm9kZScpKSwgc2VsZWN0b3IpXFxuICAgIH0sXFxuICAgIGNoaWxkcmVuOiBmdW5jdGlvbihzZWxlY3Rvcil7XFxuICAgICAgcmV0dXJuIGZpbHRlcmVkKHRoaXMubWFwKGZ1bmN0aW9uKCl7IHJldHVybiBjaGlsZHJlbih0aGlzKSB9KSwgc2VsZWN0b3IpXFxuICAgIH0sXFxuICAgIGNvbnRlbnRzOiBmdW5jdGlvbigpIHtcXG4gICAgICByZXR1cm4gdGhpcy5tYXAoZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzLmNvbnRlbnREb2N1bWVudCB8fCBzbGljZS5jYWxsKHRoaXMuY2hpbGROb2RlcykgfSlcXG4gICAgfSxcXG4gICAgc2libGluZ3M6IGZ1bmN0aW9uKHNlbGVjdG9yKXtcXG4gICAgICByZXR1cm4gZmlsdGVyZWQodGhpcy5tYXAoZnVuY3Rpb24oaSwgZWwpe1xcbiAgICAgICAgcmV0dXJuIGZpbHRlci5jYWxsKGNoaWxkcmVuKGVsLnBhcmVudE5vZGUpLCBmdW5jdGlvbihjaGlsZCl7IHJldHVybiBjaGlsZCE9PWVsIH0pXFxuICAgICAgfSksIHNlbGVjdG9yKVxcbiAgICB9LFxcbiAgICBlbXB0eTogZnVuY3Rpb24oKXtcXG4gICAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCl7IHRoaXMuaW5uZXJIVE1MID0gJycgfSlcXG4gICAgfSxcXG4gICAgLy8gYHBsdWNrYCBpcyBib3Jyb3dlZCBmcm9tIFByb3RvdHlwZS5qc1xcbiAgICBwbHVjazogZnVuY3Rpb24ocHJvcGVydHkpe1xcbiAgICAgIHJldHVybiAkLm1hcCh0aGlzLCBmdW5jdGlvbihlbCl7IHJldHVybiBlbFtwcm9wZXJ0eV0gfSlcXG4gICAgfSxcXG4gICAgc2hvdzogZnVuY3Rpb24oKXtcXG4gICAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCl7XFxuICAgICAgICB0aGlzLnN0eWxlLmRpc3BsYXkgPT0gXFxcIm5vbmVcXFwiICYmICh0aGlzLnN0eWxlLmRpc3BsYXkgPSAnJylcXG4gICAgICAgIGlmIChnZXRDb21wdXRlZFN0eWxlKHRoaXMsICcnKS5nZXRQcm9wZXJ0eVZhbHVlKFxcXCJkaXNwbGF5XFxcIikgPT0gXFxcIm5vbmVcXFwiKVxcbiAgICAgICAgICB0aGlzLnN0eWxlLmRpc3BsYXkgPSBkZWZhdWx0RGlzcGxheSh0aGlzLm5vZGVOYW1lKVxcbiAgICAgIH0pXFxuICAgIH0sXFxuICAgIHJlcGxhY2VXaXRoOiBmdW5jdGlvbihuZXdDb250ZW50KXtcXG4gICAgICByZXR1cm4gdGhpcy5iZWZvcmUobmV3Q29udGVudCkucmVtb3ZlKClcXG4gICAgfSxcXG4gICAgd3JhcDogZnVuY3Rpb24oc3RydWN0dXJlKXtcXG4gICAgICB2YXIgZnVuYyA9IGlzRnVuY3Rpb24oc3RydWN0dXJlKVxcbiAgICAgIGlmICh0aGlzWzBdICYmICFmdW5jKVxcbiAgICAgICAgdmFyIGRvbSAgID0gJChzdHJ1Y3R1cmUpLmdldCgwKSxcXG4gICAgICAgICAgICBjbG9uZSA9IGRvbS5wYXJlbnROb2RlIHx8IHRoaXMubGVuZ3RoID4gMVxcblxcbiAgICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oaW5kZXgpe1xcbiAgICAgICAgJCh0aGlzKS53cmFwQWxsKFxcbiAgICAgICAgICBmdW5jID8gc3RydWN0dXJlLmNhbGwodGhpcywgaW5kZXgpIDpcXG4gICAgICAgICAgICBjbG9uZSA/IGRvbS5jbG9uZU5vZGUodHJ1ZSkgOiBkb21cXG4gICAgICAgIClcXG4gICAgICB9KVxcbiAgICB9LFxcbiAgICB3cmFwQWxsOiBmdW5jdGlvbihzdHJ1Y3R1cmUpe1xcbiAgICAgIGlmICh0aGlzWzBdKSB7XFxuICAgICAgICAkKHRoaXNbMF0pLmJlZm9yZShzdHJ1Y3R1cmUgPSAkKHN0cnVjdHVyZSkpXFxuICAgICAgICB2YXIgY2hpbGRyZW5cXG4gICAgICAgIC8vIGRyaWxsIGRvd24gdG8gdGhlIGlubW9zdCBlbGVtZW50XFxuICAgICAgICB3aGlsZSAoKGNoaWxkcmVuID0gc3RydWN0dXJlLmNoaWxkcmVuKCkpLmxlbmd0aCkgc3RydWN0dXJlID0gY2hpbGRyZW4uZmlyc3QoKVxcbiAgICAgICAgJChzdHJ1Y3R1cmUpLmFwcGVuZCh0aGlzKVxcbiAgICAgIH1cXG4gICAgICByZXR1cm4gdGhpc1xcbiAgICB9LFxcbiAgICB3cmFwSW5uZXI6IGZ1bmN0aW9uKHN0cnVjdHVyZSl7XFxuICAgICAgdmFyIGZ1bmMgPSBpc0Z1bmN0aW9uKHN0cnVjdHVyZSlcXG4gICAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKGluZGV4KXtcXG4gICAgICAgIHZhciBzZWxmID0gJCh0aGlzKSwgY29udGVudHMgPSBzZWxmLmNvbnRlbnRzKCksXFxuICAgICAgICAgICAgZG9tICA9IGZ1bmMgPyBzdHJ1Y3R1cmUuY2FsbCh0aGlzLCBpbmRleCkgOiBzdHJ1Y3R1cmVcXG4gICAgICAgIGNvbnRlbnRzLmxlbmd0aCA/IGNvbnRlbnRzLndyYXBBbGwoZG9tKSA6IHNlbGYuYXBwZW5kKGRvbSlcXG4gICAgICB9KVxcbiAgICB9LFxcbiAgICB1bndyYXA6IGZ1bmN0aW9uKCl7XFxuICAgICAgdGhpcy5wYXJlbnQoKS5lYWNoKGZ1bmN0aW9uKCl7XFxuICAgICAgICAkKHRoaXMpLnJlcGxhY2VXaXRoKCQodGhpcykuY2hpbGRyZW4oKSlcXG4gICAgICB9KVxcbiAgICAgIHJldHVybiB0aGlzXFxuICAgIH0sXFxuICAgIGNsb25lOiBmdW5jdGlvbigpe1xcbiAgICAgIHJldHVybiB0aGlzLm1hcChmdW5jdGlvbigpeyByZXR1cm4gdGhpcy5jbG9uZU5vZGUodHJ1ZSkgfSlcXG4gICAgfSxcXG4gICAgaGlkZTogZnVuY3Rpb24oKXtcXG4gICAgICByZXR1cm4gdGhpcy5jc3MoXFxcImRpc3BsYXlcXFwiLCBcXFwibm9uZVxcXCIpXFxuICAgIH0sXFxuICAgIHRvZ2dsZTogZnVuY3Rpb24oc2V0dGluZyl7XFxuICAgICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpe1xcbiAgICAgICAgdmFyIGVsID0gJCh0aGlzKVxcbiAgICAgICAgOyhzZXR0aW5nID09PSB1bmRlZmluZWQgPyBlbC5jc3MoXFxcImRpc3BsYXlcXFwiKSA9PSBcXFwibm9uZVxcXCIgOiBzZXR0aW5nKSA/IGVsLnNob3coKSA6IGVsLmhpZGUoKVxcbiAgICAgIH0pXFxuICAgIH0sXFxuICAgIHByZXY6IGZ1bmN0aW9uKHNlbGVjdG9yKXsgcmV0dXJuICQodGhpcy5wbHVjaygncHJldmlvdXNFbGVtZW50U2libGluZycpKS5maWx0ZXIoc2VsZWN0b3IgfHwgJyonKSB9LFxcbiAgICBuZXh0OiBmdW5jdGlvbihzZWxlY3Rvcil7IHJldHVybiAkKHRoaXMucGx1Y2soJ25leHRFbGVtZW50U2libGluZycpKS5maWx0ZXIoc2VsZWN0b3IgfHwgJyonKSB9LFxcbiAgICBodG1sOiBmdW5jdGlvbihodG1sKXtcXG4gICAgICByZXR1cm4gMCBpbiBhcmd1bWVudHMgP1xcbiAgICAgICAgdGhpcy5lYWNoKGZ1bmN0aW9uKGlkeCl7XFxuICAgICAgICAgIHZhciBvcmlnaW5IdG1sID0gdGhpcy5pbm5lckhUTUxcXG4gICAgICAgICAgJCh0aGlzKS5lbXB0eSgpLmFwcGVuZCggZnVuY0FyZyh0aGlzLCBodG1sLCBpZHgsIG9yaWdpbkh0bWwpIClcXG4gICAgICAgIH0pIDpcXG4gICAgICAgICgwIGluIHRoaXMgPyB0aGlzWzBdLmlubmVySFRNTCA6IG51bGwpXFxuICAgIH0sXFxuICAgIHRleHQ6IGZ1bmN0aW9uKHRleHQpe1xcbiAgICAgIHJldHVybiAwIGluIGFyZ3VtZW50cyA/XFxuICAgICAgICB0aGlzLmVhY2goZnVuY3Rpb24oaWR4KXtcXG4gICAgICAgICAgdmFyIG5ld1RleHQgPSBmdW5jQXJnKHRoaXMsIHRleHQsIGlkeCwgdGhpcy50ZXh0Q29udGVudClcXG4gICAgICAgICAgdGhpcy50ZXh0Q29udGVudCA9IG5ld1RleHQgPT0gbnVsbCA/ICcnIDogJycrbmV3VGV4dFxcbiAgICAgICAgfSkgOlxcbiAgICAgICAgKDAgaW4gdGhpcyA/IHRoaXMucGx1Y2soJ3RleHRDb250ZW50Jykuam9pbihcXFwiXFxcIikgOiBudWxsKVxcbiAgICB9LFxcbiAgICBhdHRyOiBmdW5jdGlvbihuYW1lLCB2YWx1ZSl7XFxuICAgICAgdmFyIHJlc3VsdFxcbiAgICAgIHJldHVybiAodHlwZW9mIG5hbWUgPT0gJ3N0cmluZycgJiYgISgxIGluIGFyZ3VtZW50cykpID9cXG4gICAgICAgICgwIGluIHRoaXMgJiYgdGhpc1swXS5ub2RlVHlwZSA9PSAxICYmIChyZXN1bHQgPSB0aGlzWzBdLmdldEF0dHJpYnV0ZShuYW1lKSkgIT0gbnVsbCA/IHJlc3VsdCA6IHVuZGVmaW5lZCkgOlxcbiAgICAgICAgdGhpcy5lYWNoKGZ1bmN0aW9uKGlkeCl7XFxuICAgICAgICAgIGlmICh0aGlzLm5vZGVUeXBlICE9PSAxKSByZXR1cm5cXG4gICAgICAgICAgaWYgKGlzT2JqZWN0KG5hbWUpKSBmb3IgKGtleSBpbiBuYW1lKSBzZXRBdHRyaWJ1dGUodGhpcywga2V5LCBuYW1lW2tleV0pXFxuICAgICAgICAgIGVsc2Ugc2V0QXR0cmlidXRlKHRoaXMsIG5hbWUsIGZ1bmNBcmcodGhpcywgdmFsdWUsIGlkeCwgdGhpcy5nZXRBdHRyaWJ1dGUobmFtZSkpKVxcbiAgICAgICAgfSlcXG4gICAgfSxcXG4gICAgcmVtb3ZlQXR0cjogZnVuY3Rpb24obmFtZSl7XFxuICAgICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpeyB0aGlzLm5vZGVUeXBlID09PSAxICYmIG5hbWUuc3BsaXQoJyAnKS5mb3JFYWNoKGZ1bmN0aW9uKGF0dHJpYnV0ZSl7XFxuICAgICAgICBzZXRBdHRyaWJ1dGUodGhpcywgYXR0cmlidXRlKVxcbiAgICAgIH0sIHRoaXMpfSlcXG4gICAgfSxcXG4gICAgcHJvcDogZnVuY3Rpb24obmFtZSwgdmFsdWUpe1xcbiAgICAgIG5hbWUgPSBwcm9wTWFwW25hbWVdIHx8IG5hbWVcXG4gICAgICByZXR1cm4gKDEgaW4gYXJndW1lbnRzKSA/XFxuICAgICAgICB0aGlzLmVhY2goZnVuY3Rpb24oaWR4KXtcXG4gICAgICAgICAgdGhpc1tuYW1lXSA9IGZ1bmNBcmcodGhpcywgdmFsdWUsIGlkeCwgdGhpc1tuYW1lXSlcXG4gICAgICAgIH0pIDpcXG4gICAgICAgICh0aGlzWzBdICYmIHRoaXNbMF1bbmFtZV0pXFxuICAgIH0sXFxuICAgIHJlbW92ZVByb3A6IGZ1bmN0aW9uKG5hbWUpe1xcbiAgICAgIG5hbWUgPSBwcm9wTWFwW25hbWVdIHx8IG5hbWVcXG4gICAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCl7IGRlbGV0ZSB0aGlzW25hbWVdIH0pXFxuICAgIH0sXFxuICAgIGRhdGE6IGZ1bmN0aW9uKG5hbWUsIHZhbHVlKXtcXG4gICAgICB2YXIgYXR0ck5hbWUgPSAnZGF0YS0nICsgbmFtZS5yZXBsYWNlKGNhcGl0YWxSRSwgJy0kMScpLnRvTG93ZXJDYXNlKClcXG5cXG4gICAgICB2YXIgZGF0YSA9ICgxIGluIGFyZ3VtZW50cykgP1xcbiAgICAgICAgdGhpcy5hdHRyKGF0dHJOYW1lLCB2YWx1ZSkgOlxcbiAgICAgICAgdGhpcy5hdHRyKGF0dHJOYW1lKVxcblxcbiAgICAgIHJldHVybiBkYXRhICE9PSBudWxsID8gZGVzZXJpYWxpemVWYWx1ZShkYXRhKSA6IHVuZGVmaW5lZFxcbiAgICB9LFxcbiAgICB2YWw6IGZ1bmN0aW9uKHZhbHVlKXtcXG4gICAgICBpZiAoMCBpbiBhcmd1bWVudHMpIHtcXG4gICAgICAgIGlmICh2YWx1ZSA9PSBudWxsKSB2YWx1ZSA9IFxcXCJcXFwiXFxuICAgICAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKGlkeCl7XFxuICAgICAgICAgIHRoaXMudmFsdWUgPSBmdW5jQXJnKHRoaXMsIHZhbHVlLCBpZHgsIHRoaXMudmFsdWUpXFxuICAgICAgICB9KVxcbiAgICAgIH0gZWxzZSB7XFxuICAgICAgICByZXR1cm4gdGhpc1swXSAmJiAodGhpc1swXS5tdWx0aXBsZSA/XFxuICAgICAgICAgICAkKHRoaXNbMF0pLmZpbmQoJ29wdGlvbicpLmZpbHRlcihmdW5jdGlvbigpeyByZXR1cm4gdGhpcy5zZWxlY3RlZCB9KS5wbHVjaygndmFsdWUnKSA6XFxuICAgICAgICAgICB0aGlzWzBdLnZhbHVlKVxcbiAgICAgIH1cXG4gICAgfSxcXG4gICAgb2Zmc2V0OiBmdW5jdGlvbihjb29yZGluYXRlcyl7XFxuICAgICAgaWYgKGNvb3JkaW5hdGVzKSByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKGluZGV4KXtcXG4gICAgICAgIHZhciAkdGhpcyA9ICQodGhpcyksXFxuICAgICAgICAgICAgY29vcmRzID0gZnVuY0FyZyh0aGlzLCBjb29yZGluYXRlcywgaW5kZXgsICR0aGlzLm9mZnNldCgpKSxcXG4gICAgICAgICAgICBwYXJlbnRPZmZzZXQgPSAkdGhpcy5vZmZzZXRQYXJlbnQoKS5vZmZzZXQoKSxcXG4gICAgICAgICAgICBwcm9wcyA9IHtcXG4gICAgICAgICAgICAgIHRvcDogIGNvb3Jkcy50b3AgIC0gcGFyZW50T2Zmc2V0LnRvcCxcXG4gICAgICAgICAgICAgIGxlZnQ6IGNvb3Jkcy5sZWZ0IC0gcGFyZW50T2Zmc2V0LmxlZnRcXG4gICAgICAgICAgICB9XFxuXFxuICAgICAgICBpZiAoJHRoaXMuY3NzKCdwb3NpdGlvbicpID09ICdzdGF0aWMnKSBwcm9wc1sncG9zaXRpb24nXSA9ICdyZWxhdGl2ZSdcXG4gICAgICAgICR0aGlzLmNzcyhwcm9wcylcXG4gICAgICB9KVxcbiAgICAgIGlmICghdGhpcy5sZW5ndGgpIHJldHVybiBudWxsXFxuICAgICAgaWYgKGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCAhPT0gdGhpc1swXSAmJiAhJC5jb250YWlucyhkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQsIHRoaXNbMF0pKVxcbiAgICAgICAgcmV0dXJuIHt0b3A6IDAsIGxlZnQ6IDB9XFxuICAgICAgdmFyIG9iaiA9IHRoaXNbMF0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KClcXG4gICAgICByZXR1cm4ge1xcbiAgICAgICAgbGVmdDogb2JqLmxlZnQgKyB3aW5kb3cucGFnZVhPZmZzZXQsXFxuICAgICAgICB0b3A6IG9iai50b3AgKyB3aW5kb3cucGFnZVlPZmZzZXQsXFxuICAgICAgICB3aWR0aDogTWF0aC5yb3VuZChvYmoud2lkdGgpLFxcbiAgICAgICAgaGVpZ2h0OiBNYXRoLnJvdW5kKG9iai5oZWlnaHQpXFxuICAgICAgfVxcbiAgICB9LFxcbiAgICBjc3M6IGZ1bmN0aW9uKHByb3BlcnR5LCB2YWx1ZSl7XFxuICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAyKSB7XFxuICAgICAgICB2YXIgZWxlbWVudCA9IHRoaXNbMF1cXG4gICAgICAgIGlmICh0eXBlb2YgcHJvcGVydHkgPT0gJ3N0cmluZycpIHtcXG4gICAgICAgICAgaWYgKCFlbGVtZW50KSByZXR1cm5cXG4gICAgICAgICAgcmV0dXJuIGVsZW1lbnQuc3R5bGVbY2FtZWxpemUocHJvcGVydHkpXSB8fCBnZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQsICcnKS5nZXRQcm9wZXJ0eVZhbHVlKHByb3BlcnR5KVxcbiAgICAgICAgfSBlbHNlIGlmIChpc0FycmF5KHByb3BlcnR5KSkge1xcbiAgICAgICAgICBpZiAoIWVsZW1lbnQpIHJldHVyblxcbiAgICAgICAgICB2YXIgcHJvcHMgPSB7fVxcbiAgICAgICAgICB2YXIgY29tcHV0ZWRTdHlsZSA9IGdldENvbXB1dGVkU3R5bGUoZWxlbWVudCwgJycpXFxuICAgICAgICAgICQuZWFjaChwcm9wZXJ0eSwgZnVuY3Rpb24oXywgcHJvcCl7XFxuICAgICAgICAgICAgcHJvcHNbcHJvcF0gPSAoZWxlbWVudC5zdHlsZVtjYW1lbGl6ZShwcm9wKV0gfHwgY29tcHV0ZWRTdHlsZS5nZXRQcm9wZXJ0eVZhbHVlKHByb3ApKVxcbiAgICAgICAgICB9KVxcbiAgICAgICAgICByZXR1cm4gcHJvcHNcXG4gICAgICAgIH1cXG4gICAgICB9XFxuXFxuICAgICAgdmFyIGNzcyA9ICcnXFxuICAgICAgaWYgKHR5cGUocHJvcGVydHkpID09ICdzdHJpbmcnKSB7XFxuICAgICAgICBpZiAoIXZhbHVlICYmIHZhbHVlICE9PSAwKVxcbiAgICAgICAgICB0aGlzLmVhY2goZnVuY3Rpb24oKXsgdGhpcy5zdHlsZS5yZW1vdmVQcm9wZXJ0eShkYXNoZXJpemUocHJvcGVydHkpKSB9KVxcbiAgICAgICAgZWxzZVxcbiAgICAgICAgICBjc3MgPSBkYXNoZXJpemUocHJvcGVydHkpICsgXFxcIjpcXFwiICsgbWF5YmVBZGRQeChwcm9wZXJ0eSwgdmFsdWUpXFxuICAgICAgfSBlbHNlIHtcXG4gICAgICAgIGZvciAoa2V5IGluIHByb3BlcnR5KVxcbiAgICAgICAgICBpZiAoIXByb3BlcnR5W2tleV0gJiYgcHJvcGVydHlba2V5XSAhPT0gMClcXG4gICAgICAgICAgICB0aGlzLmVhY2goZnVuY3Rpb24oKXsgdGhpcy5zdHlsZS5yZW1vdmVQcm9wZXJ0eShkYXNoZXJpemUoa2V5KSkgfSlcXG4gICAgICAgICAgZWxzZVxcbiAgICAgICAgICAgIGNzcyArPSBkYXNoZXJpemUoa2V5KSArICc6JyArIG1heWJlQWRkUHgoa2V5LCBwcm9wZXJ0eVtrZXldKSArICc7J1xcbiAgICAgIH1cXG5cXG4gICAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCl7IHRoaXMuc3R5bGUuY3NzVGV4dCArPSAnOycgKyBjc3MgfSlcXG4gICAgfSxcXG4gICAgaW5kZXg6IGZ1bmN0aW9uKGVsZW1lbnQpe1xcbiAgICAgIHJldHVybiBlbGVtZW50ID8gdGhpcy5pbmRleE9mKCQoZWxlbWVudClbMF0pIDogdGhpcy5wYXJlbnQoKS5jaGlsZHJlbigpLmluZGV4T2YodGhpc1swXSlcXG4gICAgfSxcXG4gICAgaGFzQ2xhc3M6IGZ1bmN0aW9uKG5hbWUpe1xcbiAgICAgIGlmICghbmFtZSkgcmV0dXJuIGZhbHNlXFxuICAgICAgcmV0dXJuIGVtcHR5QXJyYXkuc29tZS5jYWxsKHRoaXMsIGZ1bmN0aW9uKGVsKXtcXG4gICAgICAgIHJldHVybiB0aGlzLnRlc3QoY2xhc3NOYW1lKGVsKSlcXG4gICAgICB9LCBjbGFzc1JFKG5hbWUpKVxcbiAgICB9LFxcbiAgICBhZGRDbGFzczogZnVuY3Rpb24obmFtZSl7XFxuICAgICAgaWYgKCFuYW1lKSByZXR1cm4gdGhpc1xcbiAgICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oaWR4KXtcXG4gICAgICAgIGlmICghKCdjbGFzc05hbWUnIGluIHRoaXMpKSByZXR1cm5cXG4gICAgICAgIGNsYXNzTGlzdCA9IFtdXFxuICAgICAgICB2YXIgY2xzID0gY2xhc3NOYW1lKHRoaXMpLCBuZXdOYW1lID0gZnVuY0FyZyh0aGlzLCBuYW1lLCBpZHgsIGNscylcXG4gICAgICAgIG5ld05hbWUuc3BsaXQoL1xcXFxzKy9nKS5mb3JFYWNoKGZ1bmN0aW9uKGtsYXNzKXtcXG4gICAgICAgICAgaWYgKCEkKHRoaXMpLmhhc0NsYXNzKGtsYXNzKSkgY2xhc3NMaXN0LnB1c2goa2xhc3MpXFxuICAgICAgICB9LCB0aGlzKVxcbiAgICAgICAgY2xhc3NMaXN0Lmxlbmd0aCAmJiBjbGFzc05hbWUodGhpcywgY2xzICsgKGNscyA/IFxcXCIgXFxcIiA6IFxcXCJcXFwiKSArIGNsYXNzTGlzdC5qb2luKFxcXCIgXFxcIikpXFxuICAgICAgfSlcXG4gICAgfSxcXG4gICAgcmVtb3ZlQ2xhc3M6IGZ1bmN0aW9uKG5hbWUpe1xcbiAgICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oaWR4KXtcXG4gICAgICAgIGlmICghKCdjbGFzc05hbWUnIGluIHRoaXMpKSByZXR1cm5cXG4gICAgICAgIGlmIChuYW1lID09PSB1bmRlZmluZWQpIHJldHVybiBjbGFzc05hbWUodGhpcywgJycpXFxuICAgICAgICBjbGFzc0xpc3QgPSBjbGFzc05hbWUodGhpcylcXG4gICAgICAgIGZ1bmNBcmcodGhpcywgbmFtZSwgaWR4LCBjbGFzc0xpc3QpLnNwbGl0KC9cXFxccysvZykuZm9yRWFjaChmdW5jdGlvbihrbGFzcyl7XFxuICAgICAgICAgIGNsYXNzTGlzdCA9IGNsYXNzTGlzdC5yZXBsYWNlKGNsYXNzUkUoa2xhc3MpLCBcXFwiIFxcXCIpXFxuICAgICAgICB9KVxcbiAgICAgICAgY2xhc3NOYW1lKHRoaXMsIGNsYXNzTGlzdC50cmltKCkpXFxuICAgICAgfSlcXG4gICAgfSxcXG4gICAgdG9nZ2xlQ2xhc3M6IGZ1bmN0aW9uKG5hbWUsIHdoZW4pe1xcbiAgICAgIGlmICghbmFtZSkgcmV0dXJuIHRoaXNcXG4gICAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKGlkeCl7XFxuICAgICAgICB2YXIgJHRoaXMgPSAkKHRoaXMpLCBuYW1lcyA9IGZ1bmNBcmcodGhpcywgbmFtZSwgaWR4LCBjbGFzc05hbWUodGhpcykpXFxuICAgICAgICBuYW1lcy5zcGxpdCgvXFxcXHMrL2cpLmZvckVhY2goZnVuY3Rpb24oa2xhc3Mpe1xcbiAgICAgICAgICAod2hlbiA9PT0gdW5kZWZpbmVkID8gISR0aGlzLmhhc0NsYXNzKGtsYXNzKSA6IHdoZW4pID9cXG4gICAgICAgICAgICAkdGhpcy5hZGRDbGFzcyhrbGFzcykgOiAkdGhpcy5yZW1vdmVDbGFzcyhrbGFzcylcXG4gICAgICAgIH0pXFxuICAgICAgfSlcXG4gICAgfSxcXG4gICAgc2Nyb2xsVG9wOiBmdW5jdGlvbih2YWx1ZSl7XFxuICAgICAgaWYgKCF0aGlzLmxlbmd0aCkgcmV0dXJuXFxuICAgICAgdmFyIGhhc1Njcm9sbFRvcCA9ICdzY3JvbGxUb3AnIGluIHRoaXNbMF1cXG4gICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkgcmV0dXJuIGhhc1Njcm9sbFRvcCA/IHRoaXNbMF0uc2Nyb2xsVG9wIDogdGhpc1swXS5wYWdlWU9mZnNldFxcbiAgICAgIHJldHVybiB0aGlzLmVhY2goaGFzU2Nyb2xsVG9wID9cXG4gICAgICAgIGZ1bmN0aW9uKCl7IHRoaXMuc2Nyb2xsVG9wID0gdmFsdWUgfSA6XFxuICAgICAgICBmdW5jdGlvbigpeyB0aGlzLnNjcm9sbFRvKHRoaXMuc2Nyb2xsWCwgdmFsdWUpIH0pXFxuICAgIH0sXFxuICAgIHNjcm9sbExlZnQ6IGZ1bmN0aW9uKHZhbHVlKXtcXG4gICAgICBpZiAoIXRoaXMubGVuZ3RoKSByZXR1cm5cXG4gICAgICB2YXIgaGFzU2Nyb2xsTGVmdCA9ICdzY3JvbGxMZWZ0JyBpbiB0aGlzWzBdXFxuICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHJldHVybiBoYXNTY3JvbGxMZWZ0ID8gdGhpc1swXS5zY3JvbGxMZWZ0IDogdGhpc1swXS5wYWdlWE9mZnNldFxcbiAgICAgIHJldHVybiB0aGlzLmVhY2goaGFzU2Nyb2xsTGVmdCA/XFxuICAgICAgICBmdW5jdGlvbigpeyB0aGlzLnNjcm9sbExlZnQgPSB2YWx1ZSB9IDpcXG4gICAgICAgIGZ1bmN0aW9uKCl7IHRoaXMuc2Nyb2xsVG8odmFsdWUsIHRoaXMuc2Nyb2xsWSkgfSlcXG4gICAgfSxcXG4gICAgcG9zaXRpb246IGZ1bmN0aW9uKCkge1xcbiAgICAgIGlmICghdGhpcy5sZW5ndGgpIHJldHVyblxcblxcbiAgICAgIHZhciBlbGVtID0gdGhpc1swXSxcXG4gICAgICAgIC8vIEdldCAqcmVhbCogb2Zmc2V0UGFyZW50XFxuICAgICAgICBvZmZzZXRQYXJlbnQgPSB0aGlzLm9mZnNldFBhcmVudCgpLFxcbiAgICAgICAgLy8gR2V0IGNvcnJlY3Qgb2Zmc2V0c1xcbiAgICAgICAgb2Zmc2V0ICAgICAgID0gdGhpcy5vZmZzZXQoKSxcXG4gICAgICAgIHBhcmVudE9mZnNldCA9IHJvb3ROb2RlUkUudGVzdChvZmZzZXRQYXJlbnRbMF0ubm9kZU5hbWUpID8geyB0b3A6IDAsIGxlZnQ6IDAgfSA6IG9mZnNldFBhcmVudC5vZmZzZXQoKVxcblxcbiAgICAgIC8vIFN1YnRyYWN0IGVsZW1lbnQgbWFyZ2luc1xcbiAgICAgIC8vIG5vdGU6IHdoZW4gYW4gZWxlbWVudCBoYXMgbWFyZ2luOiBhdXRvIHRoZSBvZmZzZXRMZWZ0IGFuZCBtYXJnaW5MZWZ0XFxuICAgICAgLy8gYXJlIHRoZSBzYW1lIGluIFNhZmFyaSBjYXVzaW5nIG9mZnNldC5sZWZ0IHRvIGluY29ycmVjdGx5IGJlIDBcXG4gICAgICBvZmZzZXQudG9wICAtPSBwYXJzZUZsb2F0KCAkKGVsZW0pLmNzcygnbWFyZ2luLXRvcCcpICkgfHwgMFxcbiAgICAgIG9mZnNldC5sZWZ0IC09IHBhcnNlRmxvYXQoICQoZWxlbSkuY3NzKCdtYXJnaW4tbGVmdCcpICkgfHwgMFxcblxcbiAgICAgIC8vIEFkZCBvZmZzZXRQYXJlbnQgYm9yZGVyc1xcbiAgICAgIHBhcmVudE9mZnNldC50b3AgICs9IHBhcnNlRmxvYXQoICQob2Zmc2V0UGFyZW50WzBdKS5jc3MoJ2JvcmRlci10b3Atd2lkdGgnKSApIHx8IDBcXG4gICAgICBwYXJlbnRPZmZzZXQubGVmdCArPSBwYXJzZUZsb2F0KCAkKG9mZnNldFBhcmVudFswXSkuY3NzKCdib3JkZXItbGVmdC13aWR0aCcpICkgfHwgMFxcblxcbiAgICAgIC8vIFN1YnRyYWN0IHRoZSB0d28gb2Zmc2V0c1xcbiAgICAgIHJldHVybiB7XFxuICAgICAgICB0b3A6ICBvZmZzZXQudG9wICAtIHBhcmVudE9mZnNldC50b3AsXFxuICAgICAgICBsZWZ0OiBvZmZzZXQubGVmdCAtIHBhcmVudE9mZnNldC5sZWZ0XFxuICAgICAgfVxcbiAgICB9LFxcbiAgICBvZmZzZXRQYXJlbnQ6IGZ1bmN0aW9uKCkge1xcbiAgICAgIHJldHVybiB0aGlzLm1hcChmdW5jdGlvbigpe1xcbiAgICAgICAgdmFyIHBhcmVudCA9IHRoaXMub2Zmc2V0UGFyZW50IHx8IGRvY3VtZW50LmJvZHlcXG4gICAgICAgIHdoaWxlIChwYXJlbnQgJiYgIXJvb3ROb2RlUkUudGVzdChwYXJlbnQubm9kZU5hbWUpICYmICQocGFyZW50KS5jc3MoXFxcInBvc2l0aW9uXFxcIikgPT0gXFxcInN0YXRpY1xcXCIpXFxuICAgICAgICAgIHBhcmVudCA9IHBhcmVudC5vZmZzZXRQYXJlbnRcXG4gICAgICAgIHJldHVybiBwYXJlbnRcXG4gICAgICB9KVxcbiAgICB9XFxuICB9XFxuXFxuICAvLyBmb3Igbm93XFxuICAkLmZuLmRldGFjaCA9ICQuZm4ucmVtb3ZlXFxuXFxuICAvLyBHZW5lcmF0ZSB0aGUgYHdpZHRoYCBhbmQgYGhlaWdodGAgZnVuY3Rpb25zXFxuICA7Wyd3aWR0aCcsICdoZWlnaHQnXS5mb3JFYWNoKGZ1bmN0aW9uKGRpbWVuc2lvbil7XFxuICAgIHZhciBkaW1lbnNpb25Qcm9wZXJ0eSA9XFxuICAgICAgZGltZW5zaW9uLnJlcGxhY2UoLy4vLCBmdW5jdGlvbihtKXsgcmV0dXJuIG1bMF0udG9VcHBlckNhc2UoKSB9KVxcblxcbiAgICAkLmZuW2RpbWVuc2lvbl0gPSBmdW5jdGlvbih2YWx1ZSl7XFxuICAgICAgdmFyIG9mZnNldCwgZWwgPSB0aGlzWzBdXFxuICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHJldHVybiBpc1dpbmRvdyhlbCkgPyBlbFsnaW5uZXInICsgZGltZW5zaW9uUHJvcGVydHldIDpcXG4gICAgICAgIGlzRG9jdW1lbnQoZWwpID8gZWwuZG9jdW1lbnRFbGVtZW50WydzY3JvbGwnICsgZGltZW5zaW9uUHJvcGVydHldIDpcXG4gICAgICAgIChvZmZzZXQgPSB0aGlzLm9mZnNldCgpKSAmJiBvZmZzZXRbZGltZW5zaW9uXVxcbiAgICAgIGVsc2UgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbihpZHgpe1xcbiAgICAgICAgZWwgPSAkKHRoaXMpXFxuICAgICAgICBlbC5jc3MoZGltZW5zaW9uLCBmdW5jQXJnKHRoaXMsIHZhbHVlLCBpZHgsIGVsW2RpbWVuc2lvbl0oKSkpXFxuICAgICAgfSlcXG4gICAgfVxcbiAgfSlcXG5cXG4gIGZ1bmN0aW9uIHRyYXZlcnNlTm9kZShub2RlLCBmdW4pIHtcXG4gICAgZnVuKG5vZGUpXFxuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBub2RlLmNoaWxkTm9kZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspXFxuICAgICAgdHJhdmVyc2VOb2RlKG5vZGUuY2hpbGROb2Rlc1tpXSwgZnVuKVxcbiAgfVxcblxcbiAgLy8gR2VuZXJhdGUgdGhlIGBhZnRlcmAsIGBwcmVwZW5kYCwgYGJlZm9yZWAsIGBhcHBlbmRgLFxcbiAgLy8gYGluc2VydEFmdGVyYCwgYGluc2VydEJlZm9yZWAsIGBhcHBlbmRUb2AsIGFuZCBgcHJlcGVuZFRvYCBtZXRob2RzLlxcbiAgYWRqYWNlbmN5T3BlcmF0b3JzLmZvckVhY2goZnVuY3Rpb24ob3BlcmF0b3IsIG9wZXJhdG9ySW5kZXgpIHtcXG4gICAgdmFyIGluc2lkZSA9IG9wZXJhdG9ySW5kZXggJSAyIC8vPT4gcHJlcGVuZCwgYXBwZW5kXFxuXFxuICAgICQuZm5bb3BlcmF0b3JdID0gZnVuY3Rpb24oKXtcXG4gICAgICAvLyBhcmd1bWVudHMgY2FuIGJlIG5vZGVzLCBhcnJheXMgb2Ygbm9kZXMsIFplcHRvIG9iamVjdHMgYW5kIEhUTUwgc3RyaW5nc1xcbiAgICAgIHZhciBhcmdUeXBlLCBub2RlcyA9ICQubWFwKGFyZ3VtZW50cywgZnVuY3Rpb24oYXJnKSB7XFxuICAgICAgICAgICAgdmFyIGFyciA9IFtdXFxuICAgICAgICAgICAgYXJnVHlwZSA9IHR5cGUoYXJnKVxcbiAgICAgICAgICAgIGlmIChhcmdUeXBlID09IFxcXCJhcnJheVxcXCIpIHtcXG4gICAgICAgICAgICAgIGFyZy5mb3JFYWNoKGZ1bmN0aW9uKGVsKSB7XFxuICAgICAgICAgICAgICAgIGlmIChlbC5ub2RlVHlwZSAhPT0gdW5kZWZpbmVkKSByZXR1cm4gYXJyLnB1c2goZWwpXFxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKCQuemVwdG8uaXNaKGVsKSkgcmV0dXJuIGFyciA9IGFyci5jb25jYXQoZWwuZ2V0KCkpXFxuICAgICAgICAgICAgICAgIGFyciA9IGFyci5jb25jYXQoemVwdG8uZnJhZ21lbnQoZWwpKVxcbiAgICAgICAgICAgICAgfSlcXG4gICAgICAgICAgICAgIHJldHVybiBhcnJcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgcmV0dXJuIGFyZ1R5cGUgPT0gXFxcIm9iamVjdFxcXCIgfHwgYXJnID09IG51bGwgP1xcbiAgICAgICAgICAgICAgYXJnIDogemVwdG8uZnJhZ21lbnQoYXJnKVxcbiAgICAgICAgICB9KSxcXG4gICAgICAgICAgcGFyZW50LCBjb3B5QnlDbG9uZSA9IHRoaXMubGVuZ3RoID4gMVxcbiAgICAgIGlmIChub2Rlcy5sZW5ndGggPCAxKSByZXR1cm4gdGhpc1xcblxcbiAgICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oXywgdGFyZ2V0KXtcXG4gICAgICAgIHBhcmVudCA9IGluc2lkZSA/IHRhcmdldCA6IHRhcmdldC5wYXJlbnROb2RlXFxuXFxuICAgICAgICAvLyBjb252ZXJ0IGFsbCBtZXRob2RzIHRvIGEgXFxcImJlZm9yZVxcXCIgb3BlcmF0aW9uXFxuICAgICAgICB0YXJnZXQgPSBvcGVyYXRvckluZGV4ID09IDAgPyB0YXJnZXQubmV4dFNpYmxpbmcgOlxcbiAgICAgICAgICAgICAgICAgb3BlcmF0b3JJbmRleCA9PSAxID8gdGFyZ2V0LmZpcnN0Q2hpbGQgOlxcbiAgICAgICAgICAgICAgICAgb3BlcmF0b3JJbmRleCA9PSAyID8gdGFyZ2V0IDpcXG4gICAgICAgICAgICAgICAgIG51bGxcXG5cXG4gICAgICAgIHZhciBwYXJlbnRJbkRvY3VtZW50ID0gJC5jb250YWlucyhkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQsIHBhcmVudClcXG5cXG4gICAgICAgIG5vZGVzLmZvckVhY2goZnVuY3Rpb24obm9kZSl7XFxuICAgICAgICAgIGlmIChjb3B5QnlDbG9uZSkgbm9kZSA9IG5vZGUuY2xvbmVOb2RlKHRydWUpXFxuICAgICAgICAgIGVsc2UgaWYgKCFwYXJlbnQpIHJldHVybiAkKG5vZGUpLnJlbW92ZSgpXFxuXFxuICAgICAgICAgIHBhcmVudC5pbnNlcnRCZWZvcmUobm9kZSwgdGFyZ2V0KVxcbiAgICAgICAgICBpZiAocGFyZW50SW5Eb2N1bWVudCkgdHJhdmVyc2VOb2RlKG5vZGUsIGZ1bmN0aW9uKGVsKXtcXG4gICAgICAgICAgICBpZiAoZWwubm9kZU5hbWUgIT0gbnVsbCAmJiBlbC5ub2RlTmFtZS50b1VwcGVyQ2FzZSgpID09PSAnU0NSSVBUJyAmJlxcbiAgICAgICAgICAgICAgICghZWwudHlwZSB8fCBlbC50eXBlID09PSAndGV4dC9qYXZhc2NyaXB0JykgJiYgIWVsLnNyYyl7XFxuICAgICAgICAgICAgICB2YXIgdGFyZ2V0ID0gZWwub3duZXJEb2N1bWVudCA/IGVsLm93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXcgOiB3aW5kb3dcXG4gICAgICAgICAgICAgIHRhcmdldFsnZXZhbCddLmNhbGwodGFyZ2V0LCBlbC5pbm5lckhUTUwpXFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICB9KVxcbiAgICAgICAgfSlcXG4gICAgICB9KVxcbiAgICB9XFxuXFxuICAgIC8vIGFmdGVyICAgID0+IGluc2VydEFmdGVyXFxuICAgIC8vIHByZXBlbmQgID0+IHByZXBlbmRUb1xcbiAgICAvLyBiZWZvcmUgICA9PiBpbnNlcnRCZWZvcmVcXG4gICAgLy8gYXBwZW5kICAgPT4gYXBwZW5kVG9cXG4gICAgJC5mbltpbnNpZGUgPyBvcGVyYXRvcisnVG8nIDogJ2luc2VydCcrKG9wZXJhdG9ySW5kZXggPyAnQmVmb3JlJyA6ICdBZnRlcicpXSA9IGZ1bmN0aW9uKGh0bWwpe1xcbiAgICAgICQoaHRtbClbb3BlcmF0b3JdKHRoaXMpXFxuICAgICAgcmV0dXJuIHRoaXNcXG4gICAgfVxcbiAgfSlcXG5cXG4gIHplcHRvLloucHJvdG90eXBlID0gWi5wcm90b3R5cGUgPSAkLmZuXFxuXFxuICAvLyBFeHBvcnQgaW50ZXJuYWwgQVBJIGZ1bmN0aW9ucyBpbiB0aGUgYCQuemVwdG9gIG5hbWVzcGFjZVxcbiAgemVwdG8udW5pcSA9IHVuaXFcXG4gIHplcHRvLmRlc2VyaWFsaXplVmFsdWUgPSBkZXNlcmlhbGl6ZVZhbHVlXFxuICAkLnplcHRvID0gemVwdG9cXG5cXG4gIHJldHVybiAkXFxufSkoKVxcblxcbndpbmRvdy5aZXB0byA9IFplcHRvXFxud2luZG93LiQgPT09IHVuZGVmaW5lZCAmJiAod2luZG93LiQgPSBaZXB0bylcXG5cXG47KGZ1bmN0aW9uKCQpe1xcbiAgdmFyIF96aWQgPSAxLCB1bmRlZmluZWQsXFxuICAgICAgc2xpY2UgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UsXFxuICAgICAgaXNGdW5jdGlvbiA9ICQuaXNGdW5jdGlvbixcXG4gICAgICBpc1N0cmluZyA9IGZ1bmN0aW9uKG9iail7IHJldHVybiB0eXBlb2Ygb2JqID09ICdzdHJpbmcnIH0sXFxuICAgICAgaGFuZGxlcnMgPSB7fSxcXG4gICAgICBzcGVjaWFsRXZlbnRzPXt9LFxcbiAgICAgIGZvY3VzaW5TdXBwb3J0ZWQgPSAnb25mb2N1c2luJyBpbiB3aW5kb3csXFxuICAgICAgZm9jdXMgPSB7IGZvY3VzOiAnZm9jdXNpbicsIGJsdXI6ICdmb2N1c291dCcgfSxcXG4gICAgICBob3ZlciA9IHsgbW91c2VlbnRlcjogJ21vdXNlb3ZlcicsIG1vdXNlbGVhdmU6ICdtb3VzZW91dCcgfVxcblxcbiAgc3BlY2lhbEV2ZW50cy5jbGljayA9IHNwZWNpYWxFdmVudHMubW91c2Vkb3duID0gc3BlY2lhbEV2ZW50cy5tb3VzZXVwID0gc3BlY2lhbEV2ZW50cy5tb3VzZW1vdmUgPSAnTW91c2VFdmVudHMnXFxuXFxuICBmdW5jdGlvbiB6aWQoZWxlbWVudCkge1xcbiAgICByZXR1cm4gZWxlbWVudC5femlkIHx8IChlbGVtZW50Ll96aWQgPSBfemlkKyspXFxuICB9XFxuICBmdW5jdGlvbiBmaW5kSGFuZGxlcnMoZWxlbWVudCwgZXZlbnQsIGZuLCBzZWxlY3Rvcikge1xcbiAgICBldmVudCA9IHBhcnNlKGV2ZW50KVxcbiAgICBpZiAoZXZlbnQubnMpIHZhciBtYXRjaGVyID0gbWF0Y2hlckZvcihldmVudC5ucylcXG4gICAgcmV0dXJuIChoYW5kbGVyc1t6aWQoZWxlbWVudCldIHx8IFtdKS5maWx0ZXIoZnVuY3Rpb24oaGFuZGxlcikge1xcbiAgICAgIHJldHVybiBoYW5kbGVyXFxuICAgICAgICAmJiAoIWV2ZW50LmUgIHx8IGhhbmRsZXIuZSA9PSBldmVudC5lKVxcbiAgICAgICAgJiYgKCFldmVudC5ucyB8fCBtYXRjaGVyLnRlc3QoaGFuZGxlci5ucykpXFxuICAgICAgICAmJiAoIWZuICAgICAgIHx8IHppZChoYW5kbGVyLmZuKSA9PT0gemlkKGZuKSlcXG4gICAgICAgICYmICghc2VsZWN0b3IgfHwgaGFuZGxlci5zZWwgPT0gc2VsZWN0b3IpXFxuICAgIH0pXFxuICB9XFxuICBmdW5jdGlvbiBwYXJzZShldmVudCkge1xcbiAgICB2YXIgcGFydHMgPSAoJycgKyBldmVudCkuc3BsaXQoJy4nKVxcbiAgICByZXR1cm4ge2U6IHBhcnRzWzBdLCBuczogcGFydHMuc2xpY2UoMSkuc29ydCgpLmpvaW4oJyAnKX1cXG4gIH1cXG4gIGZ1bmN0aW9uIG1hdGNoZXJGb3IobnMpIHtcXG4gICAgcmV0dXJuIG5ldyBSZWdFeHAoJyg/Ol58ICknICsgbnMucmVwbGFjZSgnICcsICcgLiogPycpICsgJyg/OiB8JCknKVxcbiAgfVxcblxcbiAgZnVuY3Rpb24gZXZlbnRDYXB0dXJlKGhhbmRsZXIsIGNhcHR1cmVTZXR0aW5nKSB7XFxuICAgIHJldHVybiBoYW5kbGVyLmRlbCAmJlxcbiAgICAgICghZm9jdXNpblN1cHBvcnRlZCAmJiAoaGFuZGxlci5lIGluIGZvY3VzKSkgfHxcXG4gICAgICAhIWNhcHR1cmVTZXR0aW5nXFxuICB9XFxuXFxuICBmdW5jdGlvbiByZWFsRXZlbnQodHlwZSkge1xcbiAgICByZXR1cm4gaG92ZXJbdHlwZV0gfHwgKGZvY3VzaW5TdXBwb3J0ZWQgJiYgZm9jdXNbdHlwZV0pIHx8IHR5cGVcXG4gIH1cXG5cXG4gIGZ1bmN0aW9uIGFkZChlbGVtZW50LCBldmVudHMsIGZuLCBkYXRhLCBzZWxlY3RvciwgZGVsZWdhdG9yLCBjYXB0dXJlKXtcXG4gICAgdmFyIGlkID0gemlkKGVsZW1lbnQpLCBzZXQgPSAoaGFuZGxlcnNbaWRdIHx8IChoYW5kbGVyc1tpZF0gPSBbXSkpXFxuICAgIGV2ZW50cy5zcGxpdCgvXFxcXHMvKS5mb3JFYWNoKGZ1bmN0aW9uKGV2ZW50KXtcXG4gICAgICBpZiAoZXZlbnQgPT0gJ3JlYWR5JykgcmV0dXJuICQoZG9jdW1lbnQpLnJlYWR5KGZuKVxcbiAgICAgIHZhciBoYW5kbGVyICAgPSBwYXJzZShldmVudClcXG4gICAgICBoYW5kbGVyLmZuICAgID0gZm5cXG4gICAgICBoYW5kbGVyLnNlbCAgID0gc2VsZWN0b3JcXG4gICAgICAvLyBlbXVsYXRlIG1vdXNlZW50ZXIsIG1vdXNlbGVhdmVcXG4gICAgICBpZiAoaGFuZGxlci5lIGluIGhvdmVyKSBmbiA9IGZ1bmN0aW9uKGUpe1xcbiAgICAgICAgdmFyIHJlbGF0ZWQgPSBlLnJlbGF0ZWRUYXJnZXRcXG4gICAgICAgIGlmICghcmVsYXRlZCB8fCAocmVsYXRlZCAhPT0gdGhpcyAmJiAhJC5jb250YWlucyh0aGlzLCByZWxhdGVkKSkpXFxuICAgICAgICAgIHJldHVybiBoYW5kbGVyLmZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cylcXG4gICAgICB9XFxuICAgICAgaGFuZGxlci5kZWwgICA9IGRlbGVnYXRvclxcbiAgICAgIHZhciBjYWxsYmFjayAgPSBkZWxlZ2F0b3IgfHwgZm5cXG4gICAgICBoYW5kbGVyLnByb3h5ID0gZnVuY3Rpb24oZSl7XFxuICAgICAgICBlID0gY29tcGF0aWJsZShlKVxcbiAgICAgICAgaWYgKGUuaXNJbW1lZGlhdGVQcm9wYWdhdGlvblN0b3BwZWQoKSkgcmV0dXJuXFxuICAgICAgICBlLmRhdGEgPSBkYXRhXFxuICAgICAgICB2YXIgcmVzdWx0ID0gY2FsbGJhY2suYXBwbHkoZWxlbWVudCwgZS5fYXJncyA9PSB1bmRlZmluZWQgPyBbZV0gOiBbZV0uY29uY2F0KGUuX2FyZ3MpKVxcbiAgICAgICAgaWYgKHJlc3VsdCA9PT0gZmFsc2UpIGUucHJldmVudERlZmF1bHQoKSwgZS5zdG9wUHJvcGFnYXRpb24oKVxcbiAgICAgICAgcmV0dXJuIHJlc3VsdFxcbiAgICAgIH1cXG4gICAgICBoYW5kbGVyLmkgPSBzZXQubGVuZ3RoXFxuICAgICAgc2V0LnB1c2goaGFuZGxlcilcXG4gICAgICBpZiAoJ2FkZEV2ZW50TGlzdGVuZXInIGluIGVsZW1lbnQpXFxuICAgICAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIocmVhbEV2ZW50KGhhbmRsZXIuZSksIGhhbmRsZXIucHJveHksIGV2ZW50Q2FwdHVyZShoYW5kbGVyLCBjYXB0dXJlKSlcXG4gICAgfSlcXG4gIH1cXG4gIGZ1bmN0aW9uIHJlbW92ZShlbGVtZW50LCBldmVudHMsIGZuLCBzZWxlY3RvciwgY2FwdHVyZSl7XFxuICAgIHZhciBpZCA9IHppZChlbGVtZW50KVxcbiAgICA7KGV2ZW50cyB8fCAnJykuc3BsaXQoL1xcXFxzLykuZm9yRWFjaChmdW5jdGlvbihldmVudCl7XFxuICAgICAgZmluZEhhbmRsZXJzKGVsZW1lbnQsIGV2ZW50LCBmbiwgc2VsZWN0b3IpLmZvckVhY2goZnVuY3Rpb24oaGFuZGxlcil7XFxuICAgICAgICBkZWxldGUgaGFuZGxlcnNbaWRdW2hhbmRsZXIuaV1cXG4gICAgICBpZiAoJ3JlbW92ZUV2ZW50TGlzdGVuZXInIGluIGVsZW1lbnQpXFxuICAgICAgICBlbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIocmVhbEV2ZW50KGhhbmRsZXIuZSksIGhhbmRsZXIucHJveHksIGV2ZW50Q2FwdHVyZShoYW5kbGVyLCBjYXB0dXJlKSlcXG4gICAgICB9KVxcbiAgICB9KVxcbiAgfVxcblxcbiAgJC5ldmVudCA9IHsgYWRkOiBhZGQsIHJlbW92ZTogcmVtb3ZlIH1cXG5cXG4gICQucHJveHkgPSBmdW5jdGlvbihmbiwgY29udGV4dCkge1xcbiAgICB2YXIgYXJncyA9ICgyIGluIGFyZ3VtZW50cykgJiYgc2xpY2UuY2FsbChhcmd1bWVudHMsIDIpXFxuICAgIGlmIChpc0Z1bmN0aW9uKGZuKSkge1xcbiAgICAgIHZhciBwcm94eUZuID0gZnVuY3Rpb24oKXsgcmV0dXJuIGZuLmFwcGx5KGNvbnRleHQsIGFyZ3MgPyBhcmdzLmNvbmNhdChzbGljZS5jYWxsKGFyZ3VtZW50cykpIDogYXJndW1lbnRzKSB9XFxuICAgICAgcHJveHlGbi5femlkID0gemlkKGZuKVxcbiAgICAgIHJldHVybiBwcm94eUZuXFxuICAgIH0gZWxzZSBpZiAoaXNTdHJpbmcoY29udGV4dCkpIHtcXG4gICAgICBpZiAoYXJncykge1xcbiAgICAgICAgYXJncy51bnNoaWZ0KGZuW2NvbnRleHRdLCBmbilcXG4gICAgICAgIHJldHVybiAkLnByb3h5LmFwcGx5KG51bGwsIGFyZ3MpXFxuICAgICAgfSBlbHNlIHtcXG4gICAgICAgIHJldHVybiAkLnByb3h5KGZuW2NvbnRleHRdLCBmbilcXG4gICAgICB9XFxuICAgIH0gZWxzZSB7XFxuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcXFwiZXhwZWN0ZWQgZnVuY3Rpb25cXFwiKVxcbiAgICB9XFxuICB9XFxuXFxuICAkLmZuLmJpbmQgPSBmdW5jdGlvbihldmVudCwgZGF0YSwgY2FsbGJhY2spe1xcbiAgICByZXR1cm4gdGhpcy5vbihldmVudCwgZGF0YSwgY2FsbGJhY2spXFxuICB9XFxuICAkLmZuLnVuYmluZCA9IGZ1bmN0aW9uKGV2ZW50LCBjYWxsYmFjayl7XFxuICAgIHJldHVybiB0aGlzLm9mZihldmVudCwgY2FsbGJhY2spXFxuICB9XFxuICAkLmZuLm9uZSA9IGZ1bmN0aW9uKGV2ZW50LCBzZWxlY3RvciwgZGF0YSwgY2FsbGJhY2spe1xcbiAgICByZXR1cm4gdGhpcy5vbihldmVudCwgc2VsZWN0b3IsIGRhdGEsIGNhbGxiYWNrLCAxKVxcbiAgfVxcblxcbiAgdmFyIHJldHVyblRydWUgPSBmdW5jdGlvbigpe3JldHVybiB0cnVlfSxcXG4gICAgICByZXR1cm5GYWxzZSA9IGZ1bmN0aW9uKCl7cmV0dXJuIGZhbHNlfSxcXG4gICAgICBpZ25vcmVQcm9wZXJ0aWVzID0gL14oW0EtWl18cmV0dXJuVmFsdWUkfGxheWVyW1hZXSR8d2Via2l0TW92ZW1lbnRbWFldJCkvLFxcbiAgICAgIGV2ZW50TWV0aG9kcyA9IHtcXG4gICAgICAgIHByZXZlbnREZWZhdWx0OiAnaXNEZWZhdWx0UHJldmVudGVkJyxcXG4gICAgICAgIHN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbjogJ2lzSW1tZWRpYXRlUHJvcGFnYXRpb25TdG9wcGVkJyxcXG4gICAgICAgIHN0b3BQcm9wYWdhdGlvbjogJ2lzUHJvcGFnYXRpb25TdG9wcGVkJ1xcbiAgICAgIH1cXG5cXG4gIGZ1bmN0aW9uIGNvbXBhdGlibGUoZXZlbnQsIHNvdXJjZSkge1xcbiAgICBpZiAoc291cmNlIHx8ICFldmVudC5pc0RlZmF1bHRQcmV2ZW50ZWQpIHtcXG4gICAgICBzb3VyY2UgfHwgKHNvdXJjZSA9IGV2ZW50KVxcblxcbiAgICAgICQuZWFjaChldmVudE1ldGhvZHMsIGZ1bmN0aW9uKG5hbWUsIHByZWRpY2F0ZSkge1xcbiAgICAgICAgdmFyIHNvdXJjZU1ldGhvZCA9IHNvdXJjZVtuYW1lXVxcbiAgICAgICAgZXZlbnRbbmFtZV0gPSBmdW5jdGlvbigpe1xcbiAgICAgICAgICB0aGlzW3ByZWRpY2F0ZV0gPSByZXR1cm5UcnVlXFxuICAgICAgICAgIHJldHVybiBzb3VyY2VNZXRob2QgJiYgc291cmNlTWV0aG9kLmFwcGx5KHNvdXJjZSwgYXJndW1lbnRzKVxcbiAgICAgICAgfVxcbiAgICAgICAgZXZlbnRbcHJlZGljYXRlXSA9IHJldHVybkZhbHNlXFxuICAgICAgfSlcXG5cXG4gICAgICBldmVudC50aW1lU3RhbXAgfHwgKGV2ZW50LnRpbWVTdGFtcCA9IERhdGUubm93KCkpXFxuXFxuICAgICAgaWYgKHNvdXJjZS5kZWZhdWx0UHJldmVudGVkICE9PSB1bmRlZmluZWQgPyBzb3VyY2UuZGVmYXVsdFByZXZlbnRlZCA6XFxuICAgICAgICAgICdyZXR1cm5WYWx1ZScgaW4gc291cmNlID8gc291cmNlLnJldHVyblZhbHVlID09PSBmYWxzZSA6XFxuICAgICAgICAgIHNvdXJjZS5nZXRQcmV2ZW50RGVmYXVsdCAmJiBzb3VyY2UuZ2V0UHJldmVudERlZmF1bHQoKSlcXG4gICAgICAgIGV2ZW50LmlzRGVmYXVsdFByZXZlbnRlZCA9IHJldHVyblRydWVcXG4gICAgfVxcbiAgICByZXR1cm4gZXZlbnRcXG4gIH1cXG5cXG4gIGZ1bmN0aW9uIGNyZWF0ZVByb3h5KGV2ZW50KSB7XFxuICAgIHZhciBrZXksIHByb3h5ID0geyBvcmlnaW5hbEV2ZW50OiBldmVudCB9XFxuICAgIGZvciAoa2V5IGluIGV2ZW50KVxcbiAgICAgIGlmICghaWdub3JlUHJvcGVydGllcy50ZXN0KGtleSkgJiYgZXZlbnRba2V5XSAhPT0gdW5kZWZpbmVkKSBwcm94eVtrZXldID0gZXZlbnRba2V5XVxcblxcbiAgICByZXR1cm4gY29tcGF0aWJsZShwcm94eSwgZXZlbnQpXFxuICB9XFxuXFxuICAkLmZuLmRlbGVnYXRlID0gZnVuY3Rpb24oc2VsZWN0b3IsIGV2ZW50LCBjYWxsYmFjayl7XFxuICAgIHJldHVybiB0aGlzLm9uKGV2ZW50LCBzZWxlY3RvciwgY2FsbGJhY2spXFxuICB9XFxuICAkLmZuLnVuZGVsZWdhdGUgPSBmdW5jdGlvbihzZWxlY3RvciwgZXZlbnQsIGNhbGxiYWNrKXtcXG4gICAgcmV0dXJuIHRoaXMub2ZmKGV2ZW50LCBzZWxlY3RvciwgY2FsbGJhY2spXFxuICB9XFxuXFxuICAkLmZuLmxpdmUgPSBmdW5jdGlvbihldmVudCwgY2FsbGJhY2spe1xcbiAgICAkKGRvY3VtZW50LmJvZHkpLmRlbGVnYXRlKHRoaXMuc2VsZWN0b3IsIGV2ZW50LCBjYWxsYmFjaylcXG4gICAgcmV0dXJuIHRoaXNcXG4gIH1cXG4gICQuZm4uZGllID0gZnVuY3Rpb24oZXZlbnQsIGNhbGxiYWNrKXtcXG4gICAgJChkb2N1bWVudC5ib2R5KS51bmRlbGVnYXRlKHRoaXMuc2VsZWN0b3IsIGV2ZW50LCBjYWxsYmFjaylcXG4gICAgcmV0dXJuIHRoaXNcXG4gIH1cXG5cXG4gICQuZm4ub24gPSBmdW5jdGlvbihldmVudCwgc2VsZWN0b3IsIGRhdGEsIGNhbGxiYWNrLCBvbmUpe1xcbiAgICB2YXIgYXV0b1JlbW92ZSwgZGVsZWdhdG9yLCAkdGhpcyA9IHRoaXNcXG4gICAgaWYgKGV2ZW50ICYmICFpc1N0cmluZyhldmVudCkpIHtcXG4gICAgICAkLmVhY2goZXZlbnQsIGZ1bmN0aW9uKHR5cGUsIGZuKXtcXG4gICAgICAgICR0aGlzLm9uKHR5cGUsIHNlbGVjdG9yLCBkYXRhLCBmbiwgb25lKVxcbiAgICAgIH0pXFxuICAgICAgcmV0dXJuICR0aGlzXFxuICAgIH1cXG5cXG4gICAgaWYgKCFpc1N0cmluZyhzZWxlY3RvcikgJiYgIWlzRnVuY3Rpb24oY2FsbGJhY2spICYmIGNhbGxiYWNrICE9PSBmYWxzZSlcXG4gICAgICBjYWxsYmFjayA9IGRhdGEsIGRhdGEgPSBzZWxlY3Rvciwgc2VsZWN0b3IgPSB1bmRlZmluZWRcXG4gICAgaWYgKGNhbGxiYWNrID09PSB1bmRlZmluZWQgfHwgZGF0YSA9PT0gZmFsc2UpXFxuICAgICAgY2FsbGJhY2sgPSBkYXRhLCBkYXRhID0gdW5kZWZpbmVkXFxuXFxuICAgIGlmIChjYWxsYmFjayA9PT0gZmFsc2UpIGNhbGxiYWNrID0gcmV0dXJuRmFsc2VcXG5cXG4gICAgcmV0dXJuICR0aGlzLmVhY2goZnVuY3Rpb24oXywgZWxlbWVudCl7XFxuICAgICAgaWYgKG9uZSkgYXV0b1JlbW92ZSA9IGZ1bmN0aW9uKGUpe1xcbiAgICAgICAgcmVtb3ZlKGVsZW1lbnQsIGUudHlwZSwgY2FsbGJhY2spXFxuICAgICAgICByZXR1cm4gY2FsbGJhY2suYXBwbHkodGhpcywgYXJndW1lbnRzKVxcbiAgICAgIH1cXG5cXG4gICAgICBpZiAoc2VsZWN0b3IpIGRlbGVnYXRvciA9IGZ1bmN0aW9uKGUpe1xcbiAgICAgICAgdmFyIGV2dCwgbWF0Y2ggPSAkKGUudGFyZ2V0KS5jbG9zZXN0KHNlbGVjdG9yLCBlbGVtZW50KS5nZXQoMClcXG4gICAgICAgIGlmIChtYXRjaCAmJiBtYXRjaCAhPT0gZWxlbWVudCkge1xcbiAgICAgICAgICBldnQgPSAkLmV4dGVuZChjcmVhdGVQcm94eShlKSwge2N1cnJlbnRUYXJnZXQ6IG1hdGNoLCBsaXZlRmlyZWQ6IGVsZW1lbnR9KVxcbiAgICAgICAgICByZXR1cm4gKGF1dG9SZW1vdmUgfHwgY2FsbGJhY2spLmFwcGx5KG1hdGNoLCBbZXZ0XS5jb25jYXQoc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpKSlcXG4gICAgICAgIH1cXG4gICAgICB9XFxuXFxuICAgICAgYWRkKGVsZW1lbnQsIGV2ZW50LCBjYWxsYmFjaywgZGF0YSwgc2VsZWN0b3IsIGRlbGVnYXRvciB8fCBhdXRvUmVtb3ZlKVxcbiAgICB9KVxcbiAgfVxcbiAgJC5mbi5vZmYgPSBmdW5jdGlvbihldmVudCwgc2VsZWN0b3IsIGNhbGxiYWNrKXtcXG4gICAgdmFyICR0aGlzID0gdGhpc1xcbiAgICBpZiAoZXZlbnQgJiYgIWlzU3RyaW5nKGV2ZW50KSkge1xcbiAgICAgICQuZWFjaChldmVudCwgZnVuY3Rpb24odHlwZSwgZm4pe1xcbiAgICAgICAgJHRoaXMub2ZmKHR5cGUsIHNlbGVjdG9yLCBmbilcXG4gICAgICB9KVxcbiAgICAgIHJldHVybiAkdGhpc1xcbiAgICB9XFxuXFxuICAgIGlmICghaXNTdHJpbmcoc2VsZWN0b3IpICYmICFpc0Z1bmN0aW9uKGNhbGxiYWNrKSAmJiBjYWxsYmFjayAhPT0gZmFsc2UpXFxuICAgICAgY2FsbGJhY2sgPSBzZWxlY3Rvciwgc2VsZWN0b3IgPSB1bmRlZmluZWRcXG5cXG4gICAgaWYgKGNhbGxiYWNrID09PSBmYWxzZSkgY2FsbGJhY2sgPSByZXR1cm5GYWxzZVxcblxcbiAgICByZXR1cm4gJHRoaXMuZWFjaChmdW5jdGlvbigpe1xcbiAgICAgIHJlbW92ZSh0aGlzLCBldmVudCwgY2FsbGJhY2ssIHNlbGVjdG9yKVxcbiAgICB9KVxcbiAgfVxcblxcbiAgJC5mbi50cmlnZ2VyID0gZnVuY3Rpb24oZXZlbnQsIGFyZ3Mpe1xcbiAgICBldmVudCA9IChpc1N0cmluZyhldmVudCkgfHwgJC5pc1BsYWluT2JqZWN0KGV2ZW50KSkgPyAkLkV2ZW50KGV2ZW50KSA6IGNvbXBhdGlibGUoZXZlbnQpXFxuICAgIGV2ZW50Ll9hcmdzID0gYXJnc1xcbiAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCl7XFxuICAgICAgLy8gaGFuZGxlIGZvY3VzKCksIGJsdXIoKSBieSBjYWxsaW5nIHRoZW0gZGlyZWN0bHlcXG4gICAgICBpZiAoZXZlbnQudHlwZSBpbiBmb2N1cyAmJiB0eXBlb2YgdGhpc1tldmVudC50eXBlXSA9PSBcXFwiZnVuY3Rpb25cXFwiKSB0aGlzW2V2ZW50LnR5cGVdKClcXG4gICAgICAvLyBpdGVtcyBpbiB0aGUgY29sbGVjdGlvbiBtaWdodCBub3QgYmUgRE9NIGVsZW1lbnRzXFxuICAgICAgZWxzZSBpZiAoJ2Rpc3BhdGNoRXZlbnQnIGluIHRoaXMpIHRoaXMuZGlzcGF0Y2hFdmVudChldmVudClcXG4gICAgICBlbHNlICQodGhpcykudHJpZ2dlckhhbmRsZXIoZXZlbnQsIGFyZ3MpXFxuICAgIH0pXFxuICB9XFxuXFxuICAvLyB0cmlnZ2VycyBldmVudCBoYW5kbGVycyBvbiBjdXJyZW50IGVsZW1lbnQganVzdCBhcyBpZiBhbiBldmVudCBvY2N1cnJlZCxcXG4gIC8vIGRvZXNuJ3QgdHJpZ2dlciBhbiBhY3R1YWwgZXZlbnQsIGRvZXNuJ3QgYnViYmxlXFxuICAkLmZuLnRyaWdnZXJIYW5kbGVyID0gZnVuY3Rpb24oZXZlbnQsIGFyZ3Mpe1xcbiAgICB2YXIgZSwgcmVzdWx0XFxuICAgIHRoaXMuZWFjaChmdW5jdGlvbihpLCBlbGVtZW50KXtcXG4gICAgICBlID0gY3JlYXRlUHJveHkoaXNTdHJpbmcoZXZlbnQpID8gJC5FdmVudChldmVudCkgOiBldmVudClcXG4gICAgICBlLl9hcmdzID0gYXJnc1xcbiAgICAgIGUudGFyZ2V0ID0gZWxlbWVudFxcbiAgICAgICQuZWFjaChmaW5kSGFuZGxlcnMoZWxlbWVudCwgZXZlbnQudHlwZSB8fCBldmVudCksIGZ1bmN0aW9uKGksIGhhbmRsZXIpe1xcbiAgICAgICAgcmVzdWx0ID0gaGFuZGxlci5wcm94eShlKVxcbiAgICAgICAgaWYgKGUuaXNJbW1lZGlhdGVQcm9wYWdhdGlvblN0b3BwZWQoKSkgcmV0dXJuIGZhbHNlXFxuICAgICAgfSlcXG4gICAgfSlcXG4gICAgcmV0dXJuIHJlc3VsdFxcbiAgfVxcblxcbiAgLy8gc2hvcnRjdXQgbWV0aG9kcyBmb3IgYC5iaW5kKGV2ZW50LCBmbilgIGZvciBlYWNoIGV2ZW50IHR5cGVcXG4gIDsoJ2ZvY3VzaW4gZm9jdXNvdXQgZm9jdXMgYmx1ciBsb2FkIHJlc2l6ZSBzY3JvbGwgdW5sb2FkIGNsaWNrIGRibGNsaWNrICcrXFxuICAnbW91c2Vkb3duIG1vdXNldXAgbW91c2Vtb3ZlIG1vdXNlb3ZlciBtb3VzZW91dCBtb3VzZWVudGVyIG1vdXNlbGVhdmUgJytcXG4gICdjaGFuZ2Ugc2VsZWN0IGtleWRvd24ga2V5cHJlc3Mga2V5dXAgZXJyb3InKS5zcGxpdCgnICcpLmZvckVhY2goZnVuY3Rpb24oZXZlbnQpIHtcXG4gICAgJC5mbltldmVudF0gPSBmdW5jdGlvbihjYWxsYmFjaykge1xcbiAgICAgIHJldHVybiAoMCBpbiBhcmd1bWVudHMpID9cXG4gICAgICAgIHRoaXMuYmluZChldmVudCwgY2FsbGJhY2spIDpcXG4gICAgICAgIHRoaXMudHJpZ2dlcihldmVudClcXG4gICAgfVxcbiAgfSlcXG5cXG4gICQuRXZlbnQgPSBmdW5jdGlvbih0eXBlLCBwcm9wcykge1xcbiAgICBpZiAoIWlzU3RyaW5nKHR5cGUpKSBwcm9wcyA9IHR5cGUsIHR5cGUgPSBwcm9wcy50eXBlXFxuICAgIHZhciBldmVudCA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KHNwZWNpYWxFdmVudHNbdHlwZV0gfHwgJ0V2ZW50cycpLCBidWJibGVzID0gdHJ1ZVxcbiAgICBpZiAocHJvcHMpIGZvciAodmFyIG5hbWUgaW4gcHJvcHMpIChuYW1lID09ICdidWJibGVzJykgPyAoYnViYmxlcyA9ICEhcHJvcHNbbmFtZV0pIDogKGV2ZW50W25hbWVdID0gcHJvcHNbbmFtZV0pXFxuICAgIGV2ZW50LmluaXRFdmVudCh0eXBlLCBidWJibGVzLCB0cnVlKVxcbiAgICByZXR1cm4gY29tcGF0aWJsZShldmVudClcXG4gIH1cXG5cXG59KShaZXB0bylcXG5cXG47KGZ1bmN0aW9uKCQpe1xcbiAgdmFyIGpzb25wSUQgPSArbmV3IERhdGUoKSxcXG4gICAgICBkb2N1bWVudCA9IHdpbmRvdy5kb2N1bWVudCxcXG4gICAgICBrZXksXFxuICAgICAgbmFtZSxcXG4gICAgICByc2NyaXB0ID0gLzxzY3JpcHRcXFxcYltePF0qKD86KD8hPFxcXFwvc2NyaXB0Pik8W148XSopKjxcXFxcL3NjcmlwdD4vZ2ksXFxuICAgICAgc2NyaXB0VHlwZVJFID0gL14oPzp0ZXh0fGFwcGxpY2F0aW9uKVxcXFwvamF2YXNjcmlwdC9pLFxcbiAgICAgIHhtbFR5cGVSRSA9IC9eKD86dGV4dHxhcHBsaWNhdGlvbilcXFxcL3htbC9pLFxcbiAgICAgIGpzb25UeXBlID0gJ2FwcGxpY2F0aW9uL2pzb24nLFxcbiAgICAgIGh0bWxUeXBlID0gJ3RleHQvaHRtbCcsXFxuICAgICAgYmxhbmtSRSA9IC9eXFxcXHMqJC8sXFxuICAgICAgb3JpZ2luQW5jaG9yID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYScpXFxuXFxuICBvcmlnaW5BbmNob3IuaHJlZiA9IHdpbmRvdy5sb2NhdGlvbi5ocmVmXFxuXFxuICAvLyB0cmlnZ2VyIGEgY3VzdG9tIGV2ZW50IGFuZCByZXR1cm4gZmFsc2UgaWYgaXQgd2FzIGNhbmNlbGxlZFxcbiAgZnVuY3Rpb24gdHJpZ2dlckFuZFJldHVybihjb250ZXh0LCBldmVudE5hbWUsIGRhdGEpIHtcXG4gICAgdmFyIGV2ZW50ID0gJC5FdmVudChldmVudE5hbWUpXFxuICAgICQoY29udGV4dCkudHJpZ2dlcihldmVudCwgZGF0YSlcXG4gICAgcmV0dXJuICFldmVudC5pc0RlZmF1bHRQcmV2ZW50ZWQoKVxcbiAgfVxcblxcbiAgLy8gdHJpZ2dlciBhbiBBamF4IFxcXCJnbG9iYWxcXFwiIGV2ZW50XFxuICBmdW5jdGlvbiB0cmlnZ2VyR2xvYmFsKHNldHRpbmdzLCBjb250ZXh0LCBldmVudE5hbWUsIGRhdGEpIHtcXG4gICAgaWYgKHNldHRpbmdzLmdsb2JhbCkgcmV0dXJuIHRyaWdnZXJBbmRSZXR1cm4oY29udGV4dCB8fCBkb2N1bWVudCwgZXZlbnROYW1lLCBkYXRhKVxcbiAgfVxcblxcbiAgLy8gTnVtYmVyIG9mIGFjdGl2ZSBBamF4IHJlcXVlc3RzXFxuICAkLmFjdGl2ZSA9IDBcXG5cXG4gIGZ1bmN0aW9uIGFqYXhTdGFydChzZXR0aW5ncykge1xcbiAgICBpZiAoc2V0dGluZ3MuZ2xvYmFsICYmICQuYWN0aXZlKysgPT09IDApIHRyaWdnZXJHbG9iYWwoc2V0dGluZ3MsIG51bGwsICdhamF4U3RhcnQnKVxcbiAgfVxcbiAgZnVuY3Rpb24gYWpheFN0b3Aoc2V0dGluZ3MpIHtcXG4gICAgaWYgKHNldHRpbmdzLmdsb2JhbCAmJiAhKC0tJC5hY3RpdmUpKSB0cmlnZ2VyR2xvYmFsKHNldHRpbmdzLCBudWxsLCAnYWpheFN0b3AnKVxcbiAgfVxcblxcbiAgLy8gdHJpZ2dlcnMgYW4gZXh0cmEgZ2xvYmFsIGV2ZW50IFxcXCJhamF4QmVmb3JlU2VuZFxcXCIgdGhhdCdzIGxpa2UgXFxcImFqYXhTZW5kXFxcIiBidXQgY2FuY2VsYWJsZVxcbiAgZnVuY3Rpb24gYWpheEJlZm9yZVNlbmQoeGhyLCBzZXR0aW5ncykge1xcbiAgICB2YXIgY29udGV4dCA9IHNldHRpbmdzLmNvbnRleHRcXG4gICAgaWYgKHNldHRpbmdzLmJlZm9yZVNlbmQuY2FsbChjb250ZXh0LCB4aHIsIHNldHRpbmdzKSA9PT0gZmFsc2UgfHxcXG4gICAgICAgIHRyaWdnZXJHbG9iYWwoc2V0dGluZ3MsIGNvbnRleHQsICdhamF4QmVmb3JlU2VuZCcsIFt4aHIsIHNldHRpbmdzXSkgPT09IGZhbHNlKVxcbiAgICAgIHJldHVybiBmYWxzZVxcblxcbiAgICB0cmlnZ2VyR2xvYmFsKHNldHRpbmdzLCBjb250ZXh0LCAnYWpheFNlbmQnLCBbeGhyLCBzZXR0aW5nc10pXFxuICB9XFxuICBmdW5jdGlvbiBhamF4U3VjY2VzcyhkYXRhLCB4aHIsIHNldHRpbmdzLCBkZWZlcnJlZCkge1xcbiAgICB2YXIgY29udGV4dCA9IHNldHRpbmdzLmNvbnRleHQsIHN0YXR1cyA9ICdzdWNjZXNzJ1xcbiAgICBzZXR0aW5ncy5zdWNjZXNzLmNhbGwoY29udGV4dCwgZGF0YSwgc3RhdHVzLCB4aHIpXFxuICAgIGlmIChkZWZlcnJlZCkgZGVmZXJyZWQucmVzb2x2ZVdpdGgoY29udGV4dCwgW2RhdGEsIHN0YXR1cywgeGhyXSlcXG4gICAgdHJpZ2dlckdsb2JhbChzZXR0aW5ncywgY29udGV4dCwgJ2FqYXhTdWNjZXNzJywgW3hociwgc2V0dGluZ3MsIGRhdGFdKVxcbiAgICBhamF4Q29tcGxldGUoc3RhdHVzLCB4aHIsIHNldHRpbmdzKVxcbiAgfVxcbiAgLy8gdHlwZTogXFxcInRpbWVvdXRcXFwiLCBcXFwiZXJyb3JcXFwiLCBcXFwiYWJvcnRcXFwiLCBcXFwicGFyc2VyZXJyb3JcXFwiXFxuICBmdW5jdGlvbiBhamF4RXJyb3IoZXJyb3IsIHR5cGUsIHhociwgc2V0dGluZ3MsIGRlZmVycmVkKSB7XFxuICAgIHZhciBjb250ZXh0ID0gc2V0dGluZ3MuY29udGV4dFxcbiAgICBzZXR0aW5ncy5lcnJvci5jYWxsKGNvbnRleHQsIHhociwgdHlwZSwgZXJyb3IpXFxuICAgIGlmIChkZWZlcnJlZCkgZGVmZXJyZWQucmVqZWN0V2l0aChjb250ZXh0LCBbeGhyLCB0eXBlLCBlcnJvcl0pXFxuICAgIHRyaWdnZXJHbG9iYWwoc2V0dGluZ3MsIGNvbnRleHQsICdhamF4RXJyb3InLCBbeGhyLCBzZXR0aW5ncywgZXJyb3IgfHwgdHlwZV0pXFxuICAgIGFqYXhDb21wbGV0ZSh0eXBlLCB4aHIsIHNldHRpbmdzKVxcbiAgfVxcbiAgLy8gc3RhdHVzOiBcXFwic3VjY2Vzc1xcXCIsIFxcXCJub3Rtb2RpZmllZFxcXCIsIFxcXCJlcnJvclxcXCIsIFxcXCJ0aW1lb3V0XFxcIiwgXFxcImFib3J0XFxcIiwgXFxcInBhcnNlcmVycm9yXFxcIlxcbiAgZnVuY3Rpb24gYWpheENvbXBsZXRlKHN0YXR1cywgeGhyLCBzZXR0aW5ncykge1xcbiAgICB2YXIgY29udGV4dCA9IHNldHRpbmdzLmNvbnRleHRcXG4gICAgc2V0dGluZ3MuY29tcGxldGUuY2FsbChjb250ZXh0LCB4aHIsIHN0YXR1cylcXG4gICAgdHJpZ2dlckdsb2JhbChzZXR0aW5ncywgY29udGV4dCwgJ2FqYXhDb21wbGV0ZScsIFt4aHIsIHNldHRpbmdzXSlcXG4gICAgYWpheFN0b3Aoc2V0dGluZ3MpXFxuICB9XFxuXFxuICBmdW5jdGlvbiBhamF4RGF0YUZpbHRlcihkYXRhLCB0eXBlLCBzZXR0aW5ncykge1xcbiAgICBpZiAoc2V0dGluZ3MuZGF0YUZpbHRlciA9PSBlbXB0eSkgcmV0dXJuIGRhdGFcXG4gICAgdmFyIGNvbnRleHQgPSBzZXR0aW5ncy5jb250ZXh0XFxuICAgIHJldHVybiBzZXR0aW5ncy5kYXRhRmlsdGVyLmNhbGwoY29udGV4dCwgZGF0YSwgdHlwZSlcXG4gIH1cXG5cXG4gIC8vIEVtcHR5IGZ1bmN0aW9uLCB1c2VkIGFzIGRlZmF1bHQgY2FsbGJhY2tcXG4gIGZ1bmN0aW9uIGVtcHR5KCkge31cXG5cXG4gICQuYWpheEpTT05QID0gZnVuY3Rpb24ob3B0aW9ucywgZGVmZXJyZWQpe1xcbiAgICBpZiAoISgndHlwZScgaW4gb3B0aW9ucykpIHJldHVybiAkLmFqYXgob3B0aW9ucylcXG5cXG4gICAgdmFyIF9jYWxsYmFja05hbWUgPSBvcHRpb25zLmpzb25wQ2FsbGJhY2ssXFxuICAgICAgY2FsbGJhY2tOYW1lID0gKCQuaXNGdW5jdGlvbihfY2FsbGJhY2tOYW1lKSA/XFxuICAgICAgICBfY2FsbGJhY2tOYW1lKCkgOiBfY2FsbGJhY2tOYW1lKSB8fCAoJ1plcHRvJyArIChqc29ucElEKyspKSxcXG4gICAgICBzY3JpcHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzY3JpcHQnKSxcXG4gICAgICBvcmlnaW5hbENhbGxiYWNrID0gd2luZG93W2NhbGxiYWNrTmFtZV0sXFxuICAgICAgcmVzcG9uc2VEYXRhLFxcbiAgICAgIGFib3J0ID0gZnVuY3Rpb24oZXJyb3JUeXBlKSB7XFxuICAgICAgICAkKHNjcmlwdCkudHJpZ2dlckhhbmRsZXIoJ2Vycm9yJywgZXJyb3JUeXBlIHx8ICdhYm9ydCcpXFxuICAgICAgfSxcXG4gICAgICB4aHIgPSB7IGFib3J0OiBhYm9ydCB9LCBhYm9ydFRpbWVvdXRcXG5cXG4gICAgaWYgKGRlZmVycmVkKSBkZWZlcnJlZC5wcm9taXNlKHhocilcXG5cXG4gICAgJChzY3JpcHQpLm9uKCdsb2FkIGVycm9yJywgZnVuY3Rpb24oZSwgZXJyb3JUeXBlKXtcXG4gICAgICBjbGVhclRpbWVvdXQoYWJvcnRUaW1lb3V0KVxcbiAgICAgICQoc2NyaXB0KS5vZmYoKS5yZW1vdmUoKVxcblxcbiAgICAgIGlmIChlLnR5cGUgPT0gJ2Vycm9yJyB8fCAhcmVzcG9uc2VEYXRhKSB7XFxuICAgICAgICBhamF4RXJyb3IobnVsbCwgZXJyb3JUeXBlIHx8ICdlcnJvcicsIHhociwgb3B0aW9ucywgZGVmZXJyZWQpXFxuICAgICAgfSBlbHNlIHtcXG4gICAgICAgIGFqYXhTdWNjZXNzKHJlc3BvbnNlRGF0YVswXSwgeGhyLCBvcHRpb25zLCBkZWZlcnJlZClcXG4gICAgICB9XFxuXFxuICAgICAgd2luZG93W2NhbGxiYWNrTmFtZV0gPSBvcmlnaW5hbENhbGxiYWNrXFxuICAgICAgaWYgKHJlc3BvbnNlRGF0YSAmJiAkLmlzRnVuY3Rpb24ob3JpZ2luYWxDYWxsYmFjaykpXFxuICAgICAgICBvcmlnaW5hbENhbGxiYWNrKHJlc3BvbnNlRGF0YVswXSlcXG5cXG4gICAgICBvcmlnaW5hbENhbGxiYWNrID0gcmVzcG9uc2VEYXRhID0gdW5kZWZpbmVkXFxuICAgIH0pXFxuXFxuICAgIGlmIChhamF4QmVmb3JlU2VuZCh4aHIsIG9wdGlvbnMpID09PSBmYWxzZSkge1xcbiAgICAgIGFib3J0KCdhYm9ydCcpXFxuICAgICAgcmV0dXJuIHhoclxcbiAgICB9XFxuXFxuICAgIHdpbmRvd1tjYWxsYmFja05hbWVdID0gZnVuY3Rpb24oKXtcXG4gICAgICByZXNwb25zZURhdGEgPSBhcmd1bWVudHNcXG4gICAgfVxcblxcbiAgICBzY3JpcHQuc3JjID0gb3B0aW9ucy51cmwucmVwbGFjZSgvXFxcXD8oLispPVxcXFw/LywgJz8kMT0nICsgY2FsbGJhY2tOYW1lKVxcbiAgICBkb2N1bWVudC5oZWFkLmFwcGVuZENoaWxkKHNjcmlwdClcXG5cXG4gICAgaWYgKG9wdGlvbnMudGltZW91dCA+IDApIGFib3J0VGltZW91dCA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKXtcXG4gICAgICBhYm9ydCgndGltZW91dCcpXFxuICAgIH0sIG9wdGlvbnMudGltZW91dClcXG5cXG4gICAgcmV0dXJuIHhoclxcbiAgfVxcblxcbiAgJC5hamF4U2V0dGluZ3MgPSB7XFxuICAgIC8vIERlZmF1bHQgdHlwZSBvZiByZXF1ZXN0XFxuICAgIHR5cGU6ICdHRVQnLFxcbiAgICAvLyBDYWxsYmFjayB0aGF0IGlzIGV4ZWN1dGVkIGJlZm9yZSByZXF1ZXN0XFxuICAgIGJlZm9yZVNlbmQ6IGVtcHR5LFxcbiAgICAvLyBDYWxsYmFjayB0aGF0IGlzIGV4ZWN1dGVkIGlmIHRoZSByZXF1ZXN0IHN1Y2NlZWRzXFxuICAgIHN1Y2Nlc3M6IGVtcHR5LFxcbiAgICAvLyBDYWxsYmFjayB0aGF0IGlzIGV4ZWN1dGVkIHRoZSB0aGUgc2VydmVyIGRyb3BzIGVycm9yXFxuICAgIGVycm9yOiBlbXB0eSxcXG4gICAgLy8gQ2FsbGJhY2sgdGhhdCBpcyBleGVjdXRlZCBvbiByZXF1ZXN0IGNvbXBsZXRlIChib3RoOiBlcnJvciBhbmQgc3VjY2VzcylcXG4gICAgY29tcGxldGU6IGVtcHR5LFxcbiAgICAvLyBUaGUgY29udGV4dCBmb3IgdGhlIGNhbGxiYWNrc1xcbiAgICBjb250ZXh0OiBudWxsLFxcbiAgICAvLyBXaGV0aGVyIHRvIHRyaWdnZXIgXFxcImdsb2JhbFxcXCIgQWpheCBldmVudHNcXG4gICAgZ2xvYmFsOiB0cnVlLFxcbiAgICAvLyBUcmFuc3BvcnRcXG4gICAgeGhyOiBmdW5jdGlvbiAoKSB7XFxuICAgICAgcmV0dXJuIG5ldyB3aW5kb3cuWE1MSHR0cFJlcXVlc3QoKVxcbiAgICB9LFxcbiAgICAvLyBNSU1FIHR5cGVzIG1hcHBpbmdcXG4gICAgLy8gSUlTIHJldHVybnMgSmF2YXNjcmlwdCBhcyBcXFwiYXBwbGljYXRpb24veC1qYXZhc2NyaXB0XFxcIlxcbiAgICBhY2NlcHRzOiB7XFxuICAgICAgc2NyaXB0OiAndGV4dC9qYXZhc2NyaXB0LCBhcHBsaWNhdGlvbi9qYXZhc2NyaXB0LCBhcHBsaWNhdGlvbi94LWphdmFzY3JpcHQnLFxcbiAgICAgIGpzb246ICAganNvblR5cGUsXFxuICAgICAgeG1sOiAgICAnYXBwbGljYXRpb24veG1sLCB0ZXh0L3htbCcsXFxuICAgICAgaHRtbDogICBodG1sVHlwZSxcXG4gICAgICB0ZXh0OiAgICd0ZXh0L3BsYWluJ1xcbiAgICB9LFxcbiAgICAvLyBXaGV0aGVyIHRoZSByZXF1ZXN0IGlzIHRvIGFub3RoZXIgZG9tYWluXFxuICAgIGNyb3NzRG9tYWluOiBmYWxzZSxcXG4gICAgLy8gRGVmYXVsdCB0aW1lb3V0XFxuICAgIHRpbWVvdXQ6IDAsXFxuICAgIC8vIFdoZXRoZXIgZGF0YSBzaG91bGQgYmUgc2VyaWFsaXplZCB0byBzdHJpbmdcXG4gICAgcHJvY2Vzc0RhdGE6IHRydWUsXFxuICAgIC8vIFdoZXRoZXIgdGhlIGJyb3dzZXIgc2hvdWxkIGJlIGFsbG93ZWQgdG8gY2FjaGUgR0VUIHJlc3BvbnNlc1xcbiAgICBjYWNoZTogdHJ1ZSxcXG4gICAgLy9Vc2VkIHRvIGhhbmRsZSB0aGUgcmF3IHJlc3BvbnNlIGRhdGEgb2YgWE1MSHR0cFJlcXVlc3QuXFxuICAgIC8vVGhpcyBpcyBhIHByZS1maWx0ZXJpbmcgZnVuY3Rpb24gdG8gc2FuaXRpemUgdGhlIHJlc3BvbnNlLlxcbiAgICAvL1RoZSBzYW5pdGl6ZWQgcmVzcG9uc2Ugc2hvdWxkIGJlIHJldHVybmVkXFxuICAgIGRhdGFGaWx0ZXI6IGVtcHR5XFxuICB9XFxuXFxuICBmdW5jdGlvbiBtaW1lVG9EYXRhVHlwZShtaW1lKSB7XFxuICAgIGlmIChtaW1lKSBtaW1lID0gbWltZS5zcGxpdCgnOycsIDIpWzBdXFxuICAgIHJldHVybiBtaW1lICYmICggbWltZSA9PSBodG1sVHlwZSA/ICdodG1sJyA6XFxuICAgICAgbWltZSA9PSBqc29uVHlwZSA/ICdqc29uJyA6XFxuICAgICAgc2NyaXB0VHlwZVJFLnRlc3QobWltZSkgPyAnc2NyaXB0JyA6XFxuICAgICAgeG1sVHlwZVJFLnRlc3QobWltZSkgJiYgJ3htbCcgKSB8fCAndGV4dCdcXG4gIH1cXG5cXG4gIGZ1bmN0aW9uIGFwcGVuZFF1ZXJ5KHVybCwgcXVlcnkpIHtcXG4gICAgaWYgKHF1ZXJ5ID09ICcnKSByZXR1cm4gdXJsXFxuICAgIHJldHVybiAodXJsICsgJyYnICsgcXVlcnkpLnJlcGxhY2UoL1smP117MSwyfS8sICc/JylcXG4gIH1cXG5cXG4gIC8vIHNlcmlhbGl6ZSBwYXlsb2FkIGFuZCBhcHBlbmQgaXQgdG8gdGhlIFVSTCBmb3IgR0VUIHJlcXVlc3RzXFxuICBmdW5jdGlvbiBzZXJpYWxpemVEYXRhKG9wdGlvbnMpIHtcXG4gICAgaWYgKG9wdGlvbnMucHJvY2Vzc0RhdGEgJiYgb3B0aW9ucy5kYXRhICYmICQudHlwZShvcHRpb25zLmRhdGEpICE9IFxcXCJzdHJpbmdcXFwiKVxcbiAgICAgIG9wdGlvbnMuZGF0YSA9ICQucGFyYW0ob3B0aW9ucy5kYXRhLCBvcHRpb25zLnRyYWRpdGlvbmFsKVxcbiAgICBpZiAob3B0aW9ucy5kYXRhICYmICghb3B0aW9ucy50eXBlIHx8IG9wdGlvbnMudHlwZS50b1VwcGVyQ2FzZSgpID09ICdHRVQnIHx8ICdqc29ucCcgPT0gb3B0aW9ucy5kYXRhVHlwZSkpXFxuICAgICAgb3B0aW9ucy51cmwgPSBhcHBlbmRRdWVyeShvcHRpb25zLnVybCwgb3B0aW9ucy5kYXRhKSwgb3B0aW9ucy5kYXRhID0gdW5kZWZpbmVkXFxuICB9XFxuXFxuICAkLmFqYXggPSBmdW5jdGlvbihvcHRpb25zKXtcXG4gICAgdmFyIHNldHRpbmdzID0gJC5leHRlbmQoe30sIG9wdGlvbnMgfHwge30pLFxcbiAgICAgICAgZGVmZXJyZWQgPSAkLkRlZmVycmVkICYmICQuRGVmZXJyZWQoKSxcXG4gICAgICAgIHVybEFuY2hvciwgaGFzaEluZGV4XFxuICAgIGZvciAoa2V5IGluICQuYWpheFNldHRpbmdzKSBpZiAoc2V0dGluZ3Nba2V5XSA9PT0gdW5kZWZpbmVkKSBzZXR0aW5nc1trZXldID0gJC5hamF4U2V0dGluZ3Nba2V5XVxcblxcbiAgICBhamF4U3RhcnQoc2V0dGluZ3MpXFxuXFxuICAgIGlmICghc2V0dGluZ3MuY3Jvc3NEb21haW4pIHtcXG4gICAgICB1cmxBbmNob3IgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdhJylcXG4gICAgICB1cmxBbmNob3IuaHJlZiA9IHNldHRpbmdzLnVybFxcbiAgICAgIC8vIGNsZWFucyB1cCBVUkwgZm9yIC5ocmVmIChJRSBvbmx5KSwgc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9tYWRyb2JieS96ZXB0by9wdWxsLzEwNDlcXG4gICAgICB1cmxBbmNob3IuaHJlZiA9IHVybEFuY2hvci5ocmVmXFxuICAgICAgc2V0dGluZ3MuY3Jvc3NEb21haW4gPSAob3JpZ2luQW5jaG9yLnByb3RvY29sICsgJy8vJyArIG9yaWdpbkFuY2hvci5ob3N0KSAhPT0gKHVybEFuY2hvci5wcm90b2NvbCArICcvLycgKyB1cmxBbmNob3IuaG9zdClcXG4gICAgfVxcblxcbiAgICBpZiAoIXNldHRpbmdzLnVybCkgc2V0dGluZ3MudXJsID0gd2luZG93LmxvY2F0aW9uLnRvU3RyaW5nKClcXG4gICAgaWYgKChoYXNoSW5kZXggPSBzZXR0aW5ncy51cmwuaW5kZXhPZignIycpKSA+IC0xKSBzZXR0aW5ncy51cmwgPSBzZXR0aW5ncy51cmwuc2xpY2UoMCwgaGFzaEluZGV4KVxcbiAgICBzZXJpYWxpemVEYXRhKHNldHRpbmdzKVxcblxcbiAgICB2YXIgZGF0YVR5cGUgPSBzZXR0aW5ncy5kYXRhVHlwZSwgaGFzUGxhY2Vob2xkZXIgPSAvXFxcXD8uKz1cXFxcPy8udGVzdChzZXR0aW5ncy51cmwpXFxuICAgIGlmIChoYXNQbGFjZWhvbGRlcikgZGF0YVR5cGUgPSAnanNvbnAnXFxuXFxuICAgIGlmIChzZXR0aW5ncy5jYWNoZSA9PT0gZmFsc2UgfHwgKFxcbiAgICAgICAgICghb3B0aW9ucyB8fCBvcHRpb25zLmNhY2hlICE9PSB0cnVlKSAmJlxcbiAgICAgICAgICgnc2NyaXB0JyA9PSBkYXRhVHlwZSB8fCAnanNvbnAnID09IGRhdGFUeXBlKVxcbiAgICAgICAgKSlcXG4gICAgICBzZXR0aW5ncy51cmwgPSBhcHBlbmRRdWVyeShzZXR0aW5ncy51cmwsICdfPScgKyBEYXRlLm5vdygpKVxcblxcbiAgICBpZiAoJ2pzb25wJyA9PSBkYXRhVHlwZSkge1xcbiAgICAgIGlmICghaGFzUGxhY2Vob2xkZXIpXFxuICAgICAgICBzZXR0aW5ncy51cmwgPSBhcHBlbmRRdWVyeShzZXR0aW5ncy51cmwsXFxuICAgICAgICAgIHNldHRpbmdzLmpzb25wID8gKHNldHRpbmdzLmpzb25wICsgJz0/JykgOiBzZXR0aW5ncy5qc29ucCA9PT0gZmFsc2UgPyAnJyA6ICdjYWxsYmFjaz0/JylcXG4gICAgICByZXR1cm4gJC5hamF4SlNPTlAoc2V0dGluZ3MsIGRlZmVycmVkKVxcbiAgICB9XFxuXFxuICAgIHZhciBtaW1lID0gc2V0dGluZ3MuYWNjZXB0c1tkYXRhVHlwZV0sXFxuICAgICAgICBoZWFkZXJzID0geyB9LFxcbiAgICAgICAgc2V0SGVhZGVyID0gZnVuY3Rpb24obmFtZSwgdmFsdWUpIHsgaGVhZGVyc1tuYW1lLnRvTG93ZXJDYXNlKCldID0gW25hbWUsIHZhbHVlXSB9LFxcbiAgICAgICAgcHJvdG9jb2wgPSAvXihbXFxcXHctXSs6KVxcXFwvXFxcXC8vLnRlc3Qoc2V0dGluZ3MudXJsKSA/IFJlZ0V4cC4kMSA6IHdpbmRvdy5sb2NhdGlvbi5wcm90b2NvbCxcXG4gICAgICAgIHhociA9IHNldHRpbmdzLnhocigpLFxcbiAgICAgICAgbmF0aXZlU2V0SGVhZGVyID0geGhyLnNldFJlcXVlc3RIZWFkZXIsXFxuICAgICAgICBhYm9ydFRpbWVvdXRcXG5cXG4gICAgaWYgKGRlZmVycmVkKSBkZWZlcnJlZC5wcm9taXNlKHhocilcXG5cXG4gICAgaWYgKCFzZXR0aW5ncy5jcm9zc0RvbWFpbikgc2V0SGVhZGVyKCdYLVJlcXVlc3RlZC1XaXRoJywgJ1hNTEh0dHBSZXF1ZXN0JylcXG4gICAgc2V0SGVhZGVyKCdBY2NlcHQnLCBtaW1lIHx8ICcqLyonKVxcbiAgICBpZiAobWltZSA9IHNldHRpbmdzLm1pbWVUeXBlIHx8IG1pbWUpIHtcXG4gICAgICBpZiAobWltZS5pbmRleE9mKCcsJykgPiAtMSkgbWltZSA9IG1pbWUuc3BsaXQoJywnLCAyKVswXVxcbiAgICAgIHhoci5vdmVycmlkZU1pbWVUeXBlICYmIHhoci5vdmVycmlkZU1pbWVUeXBlKG1pbWUpXFxuICAgIH1cXG4gICAgaWYgKHNldHRpbmdzLmNvbnRlbnRUeXBlIHx8IChzZXR0aW5ncy5jb250ZW50VHlwZSAhPT0gZmFsc2UgJiYgc2V0dGluZ3MuZGF0YSAmJiBzZXR0aW5ncy50eXBlLnRvVXBwZXJDYXNlKCkgIT0gJ0dFVCcpKVxcbiAgICAgIHNldEhlYWRlcignQ29udGVudC1UeXBlJywgc2V0dGluZ3MuY29udGVudFR5cGUgfHwgJ2FwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZCcpXFxuXFxuICAgIGlmIChzZXR0aW5ncy5oZWFkZXJzKSBmb3IgKG5hbWUgaW4gc2V0dGluZ3MuaGVhZGVycykgc2V0SGVhZGVyKG5hbWUsIHNldHRpbmdzLmhlYWRlcnNbbmFtZV0pXFxuICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyID0gc2V0SGVhZGVyXFxuXFxuICAgIHhoci5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbigpe1xcbiAgICAgIGlmICh4aHIucmVhZHlTdGF0ZSA9PSA0KSB7XFxuICAgICAgICB4aHIub25yZWFkeXN0YXRlY2hhbmdlID0gZW1wdHlcXG4gICAgICAgIGNsZWFyVGltZW91dChhYm9ydFRpbWVvdXQpXFxuICAgICAgICB2YXIgcmVzdWx0LCBlcnJvciA9IGZhbHNlXFxuICAgICAgICBpZiAoKHhoci5zdGF0dXMgPj0gMjAwICYmIHhoci5zdGF0dXMgPCAzMDApIHx8IHhoci5zdGF0dXMgPT0gMzA0IHx8ICh4aHIuc3RhdHVzID09IDAgJiYgcHJvdG9jb2wgPT0gJ2ZpbGU6JykpIHtcXG4gICAgICAgICAgZGF0YVR5cGUgPSBkYXRhVHlwZSB8fCBtaW1lVG9EYXRhVHlwZShzZXR0aW5ncy5taW1lVHlwZSB8fCB4aHIuZ2V0UmVzcG9uc2VIZWFkZXIoJ2NvbnRlbnQtdHlwZScpKVxcblxcbiAgICAgICAgICBpZiAoeGhyLnJlc3BvbnNlVHlwZSA9PSAnYXJyYXlidWZmZXInIHx8IHhoci5yZXNwb25zZVR5cGUgPT0gJ2Jsb2InKVxcbiAgICAgICAgICAgIHJlc3VsdCA9IHhoci5yZXNwb25zZVxcbiAgICAgICAgICBlbHNlIHtcXG4gICAgICAgICAgICByZXN1bHQgPSB4aHIucmVzcG9uc2VUZXh0XFxuXFxuICAgICAgICAgICAgdHJ5IHtcXG4gICAgICAgICAgICAgIC8vIGh0dHA6Ly9wZXJmZWN0aW9ua2lsbHMuY29tL2dsb2JhbC1ldmFsLXdoYXQtYXJlLXRoZS1vcHRpb25zL1xcbiAgICAgICAgICAgICAgLy8gc2FuaXRpemUgcmVzcG9uc2UgYWNjb3JkaW5nbHkgaWYgZGF0YSBmaWx0ZXIgY2FsbGJhY2sgcHJvdmlkZWRcXG4gICAgICAgICAgICAgIHJlc3VsdCA9IGFqYXhEYXRhRmlsdGVyKHJlc3VsdCwgZGF0YVR5cGUsIHNldHRpbmdzKVxcbiAgICAgICAgICAgICAgaWYgKGRhdGFUeXBlID09ICdzY3JpcHQnKSAgICAoMSxldmFsKShyZXN1bHQpXFxuICAgICAgICAgICAgICBlbHNlIGlmIChkYXRhVHlwZSA9PSAneG1sJykgIHJlc3VsdCA9IHhoci5yZXNwb25zZVhNTFxcbiAgICAgICAgICAgICAgZWxzZSBpZiAoZGF0YVR5cGUgPT0gJ2pzb24nKSByZXN1bHQgPSBibGFua1JFLnRlc3QocmVzdWx0KSA/IG51bGwgOiAkLnBhcnNlSlNPTihyZXN1bHQpXFxuICAgICAgICAgICAgfSBjYXRjaCAoZSkgeyBlcnJvciA9IGUgfVxcblxcbiAgICAgICAgICAgIGlmIChlcnJvcikgcmV0dXJuIGFqYXhFcnJvcihlcnJvciwgJ3BhcnNlcmVycm9yJywgeGhyLCBzZXR0aW5ncywgZGVmZXJyZWQpXFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgYWpheFN1Y2Nlc3MocmVzdWx0LCB4aHIsIHNldHRpbmdzLCBkZWZlcnJlZClcXG4gICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgIGFqYXhFcnJvcih4aHIuc3RhdHVzVGV4dCB8fCBudWxsLCB4aHIuc3RhdHVzID8gJ2Vycm9yJyA6ICdhYm9ydCcsIHhociwgc2V0dGluZ3MsIGRlZmVycmVkKVxcbiAgICAgICAgfVxcbiAgICAgIH1cXG4gICAgfVxcblxcbiAgICBpZiAoYWpheEJlZm9yZVNlbmQoeGhyLCBzZXR0aW5ncykgPT09IGZhbHNlKSB7XFxuICAgICAgeGhyLmFib3J0KClcXG4gICAgICBhamF4RXJyb3IobnVsbCwgJ2Fib3J0JywgeGhyLCBzZXR0aW5ncywgZGVmZXJyZWQpXFxuICAgICAgcmV0dXJuIHhoclxcbiAgICB9XFxuXFxuICAgIHZhciBhc3luYyA9ICdhc3luYycgaW4gc2V0dGluZ3MgPyBzZXR0aW5ncy5hc3luYyA6IHRydWVcXG4gICAgeGhyLm9wZW4oc2V0dGluZ3MudHlwZSwgc2V0dGluZ3MudXJsLCBhc3luYywgc2V0dGluZ3MudXNlcm5hbWUsIHNldHRpbmdzLnBhc3N3b3JkKVxcblxcbiAgICBpZiAoc2V0dGluZ3MueGhyRmllbGRzKSBmb3IgKG5hbWUgaW4gc2V0dGluZ3MueGhyRmllbGRzKSB4aHJbbmFtZV0gPSBzZXR0aW5ncy54aHJGaWVsZHNbbmFtZV1cXG5cXG4gICAgZm9yIChuYW1lIGluIGhlYWRlcnMpIG5hdGl2ZVNldEhlYWRlci5hcHBseSh4aHIsIGhlYWRlcnNbbmFtZV0pXFxuXFxuICAgIGlmIChzZXR0aW5ncy50aW1lb3V0ID4gMCkgYWJvcnRUaW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbigpe1xcbiAgICAgICAgeGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGVtcHR5XFxuICAgICAgICB4aHIuYWJvcnQoKVxcbiAgICAgICAgYWpheEVycm9yKG51bGwsICd0aW1lb3V0JywgeGhyLCBzZXR0aW5ncywgZGVmZXJyZWQpXFxuICAgICAgfSwgc2V0dGluZ3MudGltZW91dClcXG5cXG4gICAgLy8gYXZvaWQgc2VuZGluZyBlbXB0eSBzdHJpbmcgKCMzMTkpXFxuICAgIHhoci5zZW5kKHNldHRpbmdzLmRhdGEgPyBzZXR0aW5ncy5kYXRhIDogbnVsbClcXG4gICAgcmV0dXJuIHhoclxcbiAgfVxcblxcbiAgLy8gaGFuZGxlIG9wdGlvbmFsIGRhdGEvc3VjY2VzcyBhcmd1bWVudHNcXG4gIGZ1bmN0aW9uIHBhcnNlQXJndW1lbnRzKHVybCwgZGF0YSwgc3VjY2VzcywgZGF0YVR5cGUpIHtcXG4gICAgaWYgKCQuaXNGdW5jdGlvbihkYXRhKSkgZGF0YVR5cGUgPSBzdWNjZXNzLCBzdWNjZXNzID0gZGF0YSwgZGF0YSA9IHVuZGVmaW5lZFxcbiAgICBpZiAoISQuaXNGdW5jdGlvbihzdWNjZXNzKSkgZGF0YVR5cGUgPSBzdWNjZXNzLCBzdWNjZXNzID0gdW5kZWZpbmVkXFxuICAgIHJldHVybiB7XFxuICAgICAgdXJsOiB1cmxcXG4gICAgLCBkYXRhOiBkYXRhXFxuICAgICwgc3VjY2Vzczogc3VjY2Vzc1xcbiAgICAsIGRhdGFUeXBlOiBkYXRhVHlwZVxcbiAgICB9XFxuICB9XFxuXFxuICAkLmdldCA9IGZ1bmN0aW9uKC8qIHVybCwgZGF0YSwgc3VjY2VzcywgZGF0YVR5cGUgKi8pe1xcbiAgICByZXR1cm4gJC5hamF4KHBhcnNlQXJndW1lbnRzLmFwcGx5KG51bGwsIGFyZ3VtZW50cykpXFxuICB9XFxuXFxuICAkLnBvc3QgPSBmdW5jdGlvbigvKiB1cmwsIGRhdGEsIHN1Y2Nlc3MsIGRhdGFUeXBlICovKXtcXG4gICAgdmFyIG9wdGlvbnMgPSBwYXJzZUFyZ3VtZW50cy5hcHBseShudWxsLCBhcmd1bWVudHMpXFxuICAgIG9wdGlvbnMudHlwZSA9ICdQT1NUJ1xcbiAgICByZXR1cm4gJC5hamF4KG9wdGlvbnMpXFxuICB9XFxuXFxuICAkLmdldEpTT04gPSBmdW5jdGlvbigvKiB1cmwsIGRhdGEsIHN1Y2Nlc3MgKi8pe1xcbiAgICB2YXIgb3B0aW9ucyA9IHBhcnNlQXJndW1lbnRzLmFwcGx5KG51bGwsIGFyZ3VtZW50cylcXG4gICAgb3B0aW9ucy5kYXRhVHlwZSA9ICdqc29uJ1xcbiAgICByZXR1cm4gJC5hamF4KG9wdGlvbnMpXFxuICB9XFxuXFxuICAkLmZuLmxvYWQgPSBmdW5jdGlvbih1cmwsIGRhdGEsIHN1Y2Nlc3Mpe1xcbiAgICBpZiAoIXRoaXMubGVuZ3RoKSByZXR1cm4gdGhpc1xcbiAgICB2YXIgc2VsZiA9IHRoaXMsIHBhcnRzID0gdXJsLnNwbGl0KC9cXFxccy8pLCBzZWxlY3RvcixcXG4gICAgICAgIG9wdGlvbnMgPSBwYXJzZUFyZ3VtZW50cyh1cmwsIGRhdGEsIHN1Y2Nlc3MpLFxcbiAgICAgICAgY2FsbGJhY2sgPSBvcHRpb25zLnN1Y2Nlc3NcXG4gICAgaWYgKHBhcnRzLmxlbmd0aCA+IDEpIG9wdGlvbnMudXJsID0gcGFydHNbMF0sIHNlbGVjdG9yID0gcGFydHNbMV1cXG4gICAgb3B0aW9ucy5zdWNjZXNzID0gZnVuY3Rpb24ocmVzcG9uc2Upe1xcbiAgICAgIHNlbGYuaHRtbChzZWxlY3RvciA/XFxuICAgICAgICAkKCc8ZGl2PicpLmh0bWwocmVzcG9uc2UucmVwbGFjZShyc2NyaXB0LCBcXFwiXFxcIikpLmZpbmQoc2VsZWN0b3IpXFxuICAgICAgICA6IHJlc3BvbnNlKVxcbiAgICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrLmFwcGx5KHNlbGYsIGFyZ3VtZW50cylcXG4gICAgfVxcbiAgICAkLmFqYXgob3B0aW9ucylcXG4gICAgcmV0dXJuIHRoaXNcXG4gIH1cXG5cXG4gIHZhciBlc2NhcGUgPSBlbmNvZGVVUklDb21wb25lbnRcXG5cXG4gIGZ1bmN0aW9uIHNlcmlhbGl6ZShwYXJhbXMsIG9iaiwgdHJhZGl0aW9uYWwsIHNjb3BlKXtcXG4gICAgdmFyIHR5cGUsIGFycmF5ID0gJC5pc0FycmF5KG9iaiksIGhhc2ggPSAkLmlzUGxhaW5PYmplY3Qob2JqKVxcbiAgICAkLmVhY2gob2JqLCBmdW5jdGlvbihrZXksIHZhbHVlKSB7XFxuICAgICAgdHlwZSA9ICQudHlwZSh2YWx1ZSlcXG4gICAgICBpZiAoc2NvcGUpIGtleSA9IHRyYWRpdGlvbmFsID8gc2NvcGUgOlxcbiAgICAgICAgc2NvcGUgKyAnWycgKyAoaGFzaCB8fCB0eXBlID09ICdvYmplY3QnIHx8IHR5cGUgPT0gJ2FycmF5JyA/IGtleSA6ICcnKSArICddJ1xcbiAgICAgIC8vIGhhbmRsZSBkYXRhIGluIHNlcmlhbGl6ZUFycmF5KCkgZm9ybWF0XFxuICAgICAgaWYgKCFzY29wZSAmJiBhcnJheSkgcGFyYW1zLmFkZCh2YWx1ZS5uYW1lLCB2YWx1ZS52YWx1ZSlcXG4gICAgICAvLyByZWN1cnNlIGludG8gbmVzdGVkIG9iamVjdHNcXG4gICAgICBlbHNlIGlmICh0eXBlID09IFxcXCJhcnJheVxcXCIgfHwgKCF0cmFkaXRpb25hbCAmJiB0eXBlID09IFxcXCJvYmplY3RcXFwiKSlcXG4gICAgICAgIHNlcmlhbGl6ZShwYXJhbXMsIHZhbHVlLCB0cmFkaXRpb25hbCwga2V5KVxcbiAgICAgIGVsc2UgcGFyYW1zLmFkZChrZXksIHZhbHVlKVxcbiAgICB9KVxcbiAgfVxcblxcbiAgJC5wYXJhbSA9IGZ1bmN0aW9uKG9iaiwgdHJhZGl0aW9uYWwpe1xcbiAgICB2YXIgcGFyYW1zID0gW11cXG4gICAgcGFyYW1zLmFkZCA9IGZ1bmN0aW9uKGtleSwgdmFsdWUpIHtcXG4gICAgICBpZiAoJC5pc0Z1bmN0aW9uKHZhbHVlKSkgdmFsdWUgPSB2YWx1ZSgpXFxuICAgICAgaWYgKHZhbHVlID09IG51bGwpIHZhbHVlID0gXFxcIlxcXCJcXG4gICAgICB0aGlzLnB1c2goZXNjYXBlKGtleSkgKyAnPScgKyBlc2NhcGUodmFsdWUpKVxcbiAgICB9XFxuICAgIHNlcmlhbGl6ZShwYXJhbXMsIG9iaiwgdHJhZGl0aW9uYWwpXFxuICAgIHJldHVybiBwYXJhbXMuam9pbignJicpLnJlcGxhY2UoLyUyMC9nLCAnKycpXFxuICB9XFxufSkoWmVwdG8pXFxuXFxuOyhmdW5jdGlvbigkKXtcXG4gICQuZm4uc2VyaWFsaXplQXJyYXkgPSBmdW5jdGlvbigpIHtcXG4gICAgdmFyIG5hbWUsIHR5cGUsIHJlc3VsdCA9IFtdLFxcbiAgICAgIGFkZCA9IGZ1bmN0aW9uKHZhbHVlKSB7XFxuICAgICAgICBpZiAodmFsdWUuZm9yRWFjaCkgcmV0dXJuIHZhbHVlLmZvckVhY2goYWRkKVxcbiAgICAgICAgcmVzdWx0LnB1c2goeyBuYW1lOiBuYW1lLCB2YWx1ZTogdmFsdWUgfSlcXG4gICAgICB9XFxuICAgIGlmICh0aGlzWzBdKSAkLmVhY2godGhpc1swXS5lbGVtZW50cywgZnVuY3Rpb24oXywgZmllbGQpe1xcbiAgICAgIHR5cGUgPSBmaWVsZC50eXBlLCBuYW1lID0gZmllbGQubmFtZVxcbiAgICAgIGlmIChuYW1lICYmIGZpZWxkLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgIT0gJ2ZpZWxkc2V0JyAmJlxcbiAgICAgICAgIWZpZWxkLmRpc2FibGVkICYmIHR5cGUgIT0gJ3N1Ym1pdCcgJiYgdHlwZSAhPSAncmVzZXQnICYmIHR5cGUgIT0gJ2J1dHRvbicgJiYgdHlwZSAhPSAnZmlsZScgJiZcXG4gICAgICAgICgodHlwZSAhPSAncmFkaW8nICYmIHR5cGUgIT0gJ2NoZWNrYm94JykgfHwgZmllbGQuY2hlY2tlZCkpXFxuICAgICAgICAgIGFkZCgkKGZpZWxkKS52YWwoKSlcXG4gICAgfSlcXG4gICAgcmV0dXJuIHJlc3VsdFxcbiAgfVxcblxcbiAgJC5mbi5zZXJpYWxpemUgPSBmdW5jdGlvbigpe1xcbiAgICB2YXIgcmVzdWx0ID0gW11cXG4gICAgdGhpcy5zZXJpYWxpemVBcnJheSgpLmZvckVhY2goZnVuY3Rpb24oZWxtKXtcXG4gICAgICByZXN1bHQucHVzaChlbmNvZGVVUklDb21wb25lbnQoZWxtLm5hbWUpICsgJz0nICsgZW5jb2RlVVJJQ29tcG9uZW50KGVsbS52YWx1ZSkpXFxuICAgIH0pXFxuICAgIHJldHVybiByZXN1bHQuam9pbignJicpXFxuICB9XFxuXFxuICAkLmZuLnN1Ym1pdCA9IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XFxuICAgIGlmICgwIGluIGFyZ3VtZW50cykgdGhpcy5iaW5kKCdzdWJtaXQnLCBjYWxsYmFjaylcXG4gICAgZWxzZSBpZiAodGhpcy5sZW5ndGgpIHtcXG4gICAgICB2YXIgZXZlbnQgPSAkLkV2ZW50KCdzdWJtaXQnKVxcbiAgICAgIHRoaXMuZXEoMCkudHJpZ2dlcihldmVudClcXG4gICAgICBpZiAoIWV2ZW50LmlzRGVmYXVsdFByZXZlbnRlZCgpKSB0aGlzLmdldCgwKS5zdWJtaXQoKVxcbiAgICB9XFxuICAgIHJldHVybiB0aGlzXFxuICB9XFxuXFxufSkoWmVwdG8pXFxuXFxuOyhmdW5jdGlvbigpe1xcbiAgLy8gZ2V0Q29tcHV0ZWRTdHlsZSBzaG91bGRuJ3QgZnJlYWsgb3V0IHdoZW4gY2FsbGVkXFxuICAvLyB3aXRob3V0IGEgdmFsaWQgZWxlbWVudCBhcyBhcmd1bWVudFxcbiAgdHJ5IHtcXG4gICAgZ2V0Q29tcHV0ZWRTdHlsZSh1bmRlZmluZWQpXFxuICB9IGNhdGNoKGUpIHtcXG4gICAgdmFyIG5hdGl2ZUdldENvbXB1dGVkU3R5bGUgPSBnZXRDb21wdXRlZFN0eWxlXFxuICAgIHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlID0gZnVuY3Rpb24oZWxlbWVudCwgcHNldWRvRWxlbWVudCl7XFxuICAgICAgdHJ5IHtcXG4gICAgICAgIHJldHVybiBuYXRpdmVHZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQsIHBzZXVkb0VsZW1lbnQpXFxuICAgICAgfSBjYXRjaChlKSB7XFxuICAgICAgICByZXR1cm4gbnVsbFxcbiAgICAgIH1cXG4gICAgfVxcbiAgfVxcbn0pKClcXG4gIHJldHVybiBaZXB0b1xcbn0pKVxcblwiIl0sIm1hcHBpbmdzIjoiQUFBQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///4\n")},function(module,exports,__webpack_require__){"use strict";eval('\n\nmodule.exports = { "default": __webpack_require__(6), __esModule: true };//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9ub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9jb3JlLWpzL2pzb24vc3RyaW5naWZ5LmpzP2Q2NjYiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSB7IFwiZGVmYXVsdFwiOiByZXF1aXJlKFwiY29yZS1qcy9saWJyYXJ5L2ZuL2pzb24vc3RyaW5naWZ5XCIpLCBfX2VzTW9kdWxlOiB0cnVlIH07Il0sIm1hcHBpbmdzIjoiOztBQUFBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///5\n')},function(module,exports,__webpack_require__){"use strict";eval("\n\nvar _stringify = __webpack_require__(5);\n\nvar _stringify2 = _interopRequireDefault(_stringify);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar core = __webpack_require__(7);\nvar $JSON = core.JSON || (core.JSON = { stringify: _stringify2.default });\nmodule.exports = function stringify(it) {\n  // eslint-disable-line no-unused-vars\n  return $JSON.stringify.apply($JSON, arguments);\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNi5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L2ZuL2pzb24vc3RyaW5naWZ5LmpzPzExMmQiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIGNvcmUgPSByZXF1aXJlKCcuLi8uLi9tb2R1bGVzL19jb3JlJyk7XG52YXIgJEpTT04gPSBjb3JlLkpTT04gfHwgKGNvcmUuSlNPTiA9IHsgc3RyaW5naWZ5OiBKU09OLnN0cmluZ2lmeSB9KTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gc3RyaW5naWZ5KGl0KSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgcmV0dXJuICRKU09OLnN0cmluZ2lmeS5hcHBseSgkSlNPTiwgYXJndW1lbnRzKTtcbn07XG4iXSwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///6\n")},function(module,exports,__webpack_require__){"use strict";eval("\n\nvar core = module.exports = { version: '2.5.7' };\nif (typeof __e == 'number') __e = core; // eslint-disable-line no-undef//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2NvcmUuanM/YjJkNCJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgY29yZSA9IG1vZHVsZS5leHBvcnRzID0geyB2ZXJzaW9uOiAnMi41LjcnIH07XG5pZiAodHlwZW9mIF9fZSA9PSAnbnVtYmVyJykgX19lID0gY29yZTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bmRlZlxuIl0sIm1hcHBpbmdzIjoiOztBQUFBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///7\n")}]]);